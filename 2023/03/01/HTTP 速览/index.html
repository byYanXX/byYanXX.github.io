<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Stay hungry. Stay foolish.">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      HTTP 速览 | yby&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>yby's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">发现</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">发现</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>HTTP 速览</h2>
  <p class="post-date">2023-03-01</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="HTTP-概念"><a href="#HTTP-概念" class="headerlink" title="HTTP 概念"></a>HTTP 概念</h1><ul>
<li>超文本传输控制协议，是应用层的协议，是两点之间传输超文本数据的约定和规范</li>
<li>基于 TCP（HTTP&#x2F;3 是基于 UDP）</li>
<li>是双向协议</li>
<li>目前主流使用的是 HTTP&#x2F;1.1</li>
</ul>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><ul>
<li>1xx：提示信息</li>
<li>2xx：服务端成功处理客户端请求<ul>
<li>200 OK：一切正常</li>
<li>204 No Content：和 200 一样，只不过没有 body 数据</li>
<li>206：分块下载或断点续传，表示 body 数据只是一部分</li>
</ul>
</li>
<li>3xx：重定向<ul>
<li>301：永久重定向，请求资源已不存在</li>
<li>302：临时重定向，请求资源还在，但 URL 有所变动</li>
<li>304：缓存重定向，用于缓存控制，表示该资源在缓存里还可以继续使用</li>
</ul>
</li>
<li>4xx：客户端错误<ul>
<li>400：笼统的错误</li>
<li>403：服务器禁止访问资源</li>
<li>404：请求资源在服务器里不存在或找不到</li>
</ul>
</li>
<li>5xx：服务端错误<ul>
<li>500：笼统的错误</li>
<li>501：资源尚不存在，以后会有，还在开发中</li>
<li>502：服务器作为网关或代理时，服务器本身正常，但访问后端服务器时发生异常</li>
<li>502：服务器繁忙，稍后再试</li>
</ul>
</li>
</ul>
<h1 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h1><ul>
<li>Host：客户端指定请求服务器的域名</li>
<li>Connection：客户端请求使用“长连接”机制</li>
<li>Content-Length：服务端响应客户端请求时，告知客户端本次数据的长度，解决“粘包”问题</li>
<li>Content-Type：服务端响应客户端请求时，告知客户端本次数据的格式，比如：UTF-8</li>
<li>Content-Encoding：服务端响应客户端请求时，告知客户端本次数据的压缩格式，比如：gzip</li>
</ul>
<h1 id="两种请求方法"><a href="#两种请求方法" class="headerlink" title="两种请求方法"></a>两种请求方法</h1><blockquote>
<p>根据 RFC 规范，GET 方法是安全且幂等的，POST 方法既不安全也不幂等。</p>
</blockquote>
<ul>
<li><p>GET：请求服务端发送资源，一般写在 URL 里，只支持 ASCII 字符，可以有 body，但一般不加</p>
</li>
<li><p>POST：根据报文 body，对资源做出处理</p>
</li>
<li><p>安全：请求的方法不会破坏服务端的资源</p>
</li>
<li><p>幂等：多次相同的操作，返回结果不变</p>
</li>
</ul>
<h1 id="有了-HTTP-为什么还要用-RPC-协议"><a href="#有了-HTTP-为什么还要用-RPC-协议" class="headerlink" title="有了 HTTP 为什么还要用 RPC 协议"></a>有了 HTTP 为什么还要用 RPC 协议</h1><p>RPC 是“远程过程调用”，不是具体的协议，而是一种调用方式。<br>先有的 RPC，后有的 HTTP。<br>早期 HTTP 主要用于 B&#x2F;S 架构，RPC 主要用于 C&#x2F;S 架构，现在两种架构融合的不错，界限的也不是那么清晰了。<br>从 HTTP 与 RPC 的区别上看：</p>
<ul>
<li>HTTP 需要知道 IP 地址与端口才能建立连接；而 RPC 由专门保存 IP 与端口的中间服务</li>
<li>HTTP&#x2F;1.1 实现了长连接；而 RPC 除了长连接，还建立了一个连接池</li>
<li>HTTP&#x2F;1.1 的报文里有很多冗余的字段，比如 Header 里的字段很多都是固定的；而 RPC 的定制化程度更高，可以用一些序列化协议去保存结构体的数据，再有就是也不用考虑浏览器行为，比如重定向之类，所以性能会比 HTTP&#x2F;1.1 更好一些 ——这也是选择 RPC 最主要的原因</li>
</ul>
<p>另外，目前 HTTP&#x2F;2 性能比很多 RPC 协议要好，但比较新，短时间内无法完全取代 RPC。</p>
<h1 id="HTTP-x2F-1-1-对-HTTP-x2F-1-0-的优化"><a href="#HTTP-x2F-1-1-对-HTTP-x2F-1-0-的优化" class="headerlink" title="HTTP&#x2F;1.1 对 HTTP&#x2F;1.0 的优化"></a>HTTP&#x2F;1.1 对 HTTP&#x2F;1.0 的优化</h1><p>改进：</p>
<ul>
<li><code>长连接</code></li>
<li><code>支持管道传输</code></li>
</ul>
<p>不足：</p>
<ul>
<li><code>请求/响应 header 大</code>：只压缩了 body 部分</li>
<li><code>header 冗余</code>：浪费空间</li>
<li><code>响应队头阻塞</code>：服务器只能按请求顺序响应</li>
<li><code>无优先级控制</code></li>
<li><code>服务端只能被动响应</code>：只能由客户端发出请求，服务端响应请求，反之不行</li>
</ul>
<h1 id="来自-HTTP-x2F-2-的优化"><a href="#来自-HTTP-x2F-2-的优化" class="headerlink" title="来自 HTTP&#x2F;2 的优化"></a>来自 HTTP&#x2F;2 的优化</h1><p>改进：</p>
<ul>
<li><code>更安全</code>：基于 HTTPS</li>
<li><code>头部压缩</code>：消除重复部分。通过客户端和服务端共同维护一张拥有所有字段的头部信息表</li>
<li><code>二进制格式</code>：将 header 和 body 部分都变为二进制帧（Frame），计算机直接识别二进制文件，更快、更有效率</li>
<li><code>并发传输</code>：为解决响应队头阻塞的问题，使用「Stream」来解决。一个 Stream 里可以有多个 Message，一个 Message 里可以有多个 Frame，不同的请求其 StreamID 都不同，接收端再通过 StreamID 按序组装，所以可以乱序发送，实现了消息的并行发送</li>
<li><code>服务器推送</code>：服务端可以向客户端主动推送消息，减少消息传递的次数。特别地，StreamID 上服务端为偶数，客户端为奇数</li>
</ul>
<p>不足：</p>
<ul>
<li><code>队头阻塞</code>：虽然解决了 HTTP&#x2F;1.1 响应队头阻塞问题，但因其基于 TCP 协议，所以收到的字节数据必须完整且连续，所以当 Stream 里某个字节数据丢失（丢包），后面的字节数据都会阻塞在内核缓冲区里，发生 TCP 队头阻塞</li>
</ul>
<h1 id="来自-HTTP-x2F-3-的优化"><a href="#来自-HTTP-x2F-3-的优化" class="headerlink" title="来自 HTTP&#x2F;3 的优化"></a>来自 HTTP&#x2F;3 的优化</h1><p>改进：</p>
<ul>
<li><code>无队头阻塞</code>：使用 UDP +「QUIC 协议」，保证某个 Stream 丢包时，其他 Stream 不会收到影响，解决 TCP 队头阻塞</li>
<li><code>连接建立更快</code>：不再使用 TCP 三次握手 + TLS 握手，而是直接 QUIC 三次握手，使用 TLS&#x2F;1.3</li>
<li><code>连接迁移</code>：HTTP 协议通过 TCP 的四元组（源 IP + 源端口 + 目的 IP + 目的端口）确定一条 TCP 连接，当网络发生切换时，IP 变了，需要重新进行 TCP 三次握手和 TLS 四次握手，发生卡顿，HTTP&#x2F;3 则是通过标记通信两端的「连接 ID」实现即使 IP 变化，但连接 ID、TLS 密钥等没有变，还是可以复用原连接，消除卡顿</li>
</ul>
<h1 id="HTTP-x2F-1-1-优缺点"><a href="#HTTP-x2F-1-1-优缺点" class="headerlink" title="HTTP&#x2F;1.1 优缺点"></a>HTTP&#x2F;1.1 优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><code>简单</code>：报文是 header + body 格式，易读好理解</li>
<li><code>灵活</code>：字段可以自定义</li>
<li><code>跨平台</code>：PC 端、移动端、……都可以用</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><code>无状态</code><ul>
<li>不用额外的资源来记录用户状态信息，每次请求都需要验证身份，比较麻烦</li>
<li>比较简单的做法是用 Cookie 技术来标识客户端</li>
</ul>
</li>
<li><code>不安全</code><ul>
<li>明文传输：内容不加密，容易被窃听</li>
<li>不去验证通信方的身份：第三方骗子冒充服务端</li>
<li>无法验证报文完整性：响应资源的内容可能遭到篡改</li>
</ul>
</li>
</ul>
<h1 id="HTTP-x2F-1-1-性能（对比-HTTP-x2F-1-0）"><a href="#HTTP-x2F-1-1-性能（对比-HTTP-x2F-1-0）" class="headerlink" title="HTTP&#x2F;1.1 性能（对比 HTTP&#x2F;1.0）"></a>HTTP&#x2F;1.1 性能（对比 HTTP&#x2F;1.0）</h1><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>HTTP&#x2F;1.0 时，每次请求都要进行一遍三次握手，反复建立、断开，开销很大，长连接就解决了这种现象。</p>
<h2 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h2><p>有了长连接，就可以管道网络传输，也就是说不必再等待服务端对第一条请求的响应后才能发第二条请求，可以连着发多条请求，但服务端因为必须按请求顺序作出相应，所以容易出现响应队头阻塞，这在 HTTP&#x2F;1.1 是没有解决的，所以这也是大部分浏览器默认关闭管道网络传输技术的原因。</p>
<h1 id="HTTP-x2F-1-1-优化技术"><a href="#HTTP-x2F-1-1-优化技术" class="headerlink" title="HTTP&#x2F;1.1 优化技术"></a>HTTP&#x2F;1.1 优化技术</h1><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>根据 HTTP&#x2F;1.1 的缺点与性能上的问题，提出如下优化思路：</p>
<ul>
<li><code>解决缺点</code>：针对不安全，提出 HTTPS</li>
</ul>
<table>
<thead>
<tr>
<th><strong>不安全</strong></th>
<th><strong>HTTPS 解决策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td>明文传输不安全：内容不加密，会被窃听</td>
<td>信息加密，公钥 + 私钥</td>
</tr>
<tr>
<td>不去验证通信方的身份：第三方骗子冒充服务端</td>
<td>摘要算法 + 数字签名</td>
</tr>
<tr>
<td>无法验证报文完整性：响应资源的内容可能遭到篡改</td>
<td>CA 颁发数字证书</td>
</tr>
</tbody></table>
<ul>
<li><code>解决性能不足</code>：针对 HTTP&#x2F;1.1 本身，提出如下优化目标</li>
</ul>
<table>
<thead>
<tr>
<th><strong>优化目标</strong></th>
<th><strong>实现方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>避免 HTTP 请求的发送</td>
<td>缓存（强制缓存、协商缓存）</td>
</tr>
<tr>
<td>需要发送 HTTP 请求时，减少发送次数</td>
<td>减少重定向、合并请求、延迟发送</td>
</tr>
<tr>
<td>减少服务器的 HTTP 响应数据的大小</td>
<td>压缩（有损压缩、无损压缩）</td>
</tr>
</tbody></table>
<h2 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h2><p>将“请求-响应”以 &lt;key-value&gt; 的形式保存在本地缓存，访问缓存里的资源就无需服务端再发送响应资源了。有强制与协商两种缓存方式。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>决定是否使用本地缓存的主动权在浏览器端，只要浏览器判断缓存没有过期，就直接使用浏览器的本地缓存。<br>由报文头部（header）里的两个字段设置过期时间：</p>
<ul>
<li><code>Cache-Control（优先级更高）</code>：相对时间</li>
<li><code>Expires</code>：绝对时间</li>
</ul>
<p>流程如下：</p>
<ul>
<li>浏览器第一次发送请求后，服务端响应资源时会在 HTTP 报文头部加上 Cache-Control</li>
<li>浏览器再次发送请求，对比请求时间和过期时间，判断缓存资源是否过期<ul>
<li>没过期，则强制使用缓存</li>
<li>否则重新发送请求</li>
</ul>
</li>
<li>服务端接收到请求后，更新头部（header）的 Cache-Control</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>决定是否使用本地缓存的主动权在用户，浏览器判断缓存过期了，但资源内容没有改变，则向用户抛出选择，由用户决定是继续使用本地缓存还是重新请求资源。<br>两种实现方式：</p>
<ul>
<li>由请求头部的 If-Modified-Since 字段和响应头部的 Last-Modified 字段实现<ul>
<li><code>Last-Modified</code>：标识响应资源最后修改的时间</li>
<li><code>If-Modified-Since</code>：发现缓存过期时，服务端对该字段与 Last-Modified 作对比<ul>
<li>如果发现资源最后的修改，则发回最新的响应资源，响应 HTTP 200 OK</li>
<li>如果发现没过期，则响应 HTTP 304 走本地缓存</li>
</ul>
</li>
</ul>
</li>
<li>由请求头部的 If-None-Match 字段和响应头部的 Etag 字段实现（优先级更高）<ul>
<li><code>Etag</code>：响应资源的唯一标识</li>
<li><code>If-None-Match</code>：发现缓存过期时，浏览器将 If-None-Match 字段值设置为 Etag 值，服务端将来自浏览器的 Etag 值与服务端的 Etag 值进行对比<ul>
<li>如果 Etag 不同，说明资源有改动，响应 HTTP 200 OK</li>
<li>如果 Etag 没变，说明资源没有改变，响应 HTTP 304 走缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>只有在未命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<p><img src="/../pictures/image-20230406201549633.png" alt="image-20230406201549633"></p>
<h2 id="减少重定向、请求合并、延迟发送"><a href="#减少重定向、请求合并、延迟发送" class="headerlink" title="减少重定向、请求合并、延迟发送"></a>减少重定向、请求合并、延迟发送</h2><ul>
<li><code>减少重定向的请求次数</code>：将重定向的工作交由代理服务器完成</li>
<li><code>请求合并</code>：使用打包工具，将 js、css 等资源合并打包成大资源来代替多个小资源的请求</li>
<li><code>延迟发送</code>：按需获取，用户暂时访问不到的资源，没必要发出请求</li>
</ul>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>通过对资源进行压缩，来减小响应数据的大小。</p>
<ul>
<li><code>无损压缩</code>：比如 gzip<ul>
<li>去除代码里多余的符号</li>
<li>生成二进制比特序列</li>
</ul>
</li>
<li><code>有损压缩</code>：比如 png 图像压缩<ul>
<li>牺牲资源质量，减小数据大小</li>
</ul>
</li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#http" >
    <span class="tag-code">http</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/03/01/%E9%94%AE%E5%85%A5%20URL%20%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/">
        <span class="nav-arrow">← </span>
        
          键入 URL 发生的事情
        
      </a>
    
    
      <a class="nav-right" href="/2023/03/01/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">
        
          网络模型
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#HTTP-%E6%A6%82%E5%BF%B5"><span class="toc-nav-text">HTTP 概念</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-nav-text">状态码</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-nav-text">常见字段</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-nav-text">两种请求方法</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E6%9C%89%E4%BA%86-HTTP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8-RPC-%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">有了 HTTP 为什么还要用 RPC 协议</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#HTTP-x2F-1-1-%E5%AF%B9-HTTP-x2F-1-0-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-nav-text">HTTP&#x2F;1.1 对 HTTP&#x2F;1.0 的优化</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E6%9D%A5%E8%87%AA-HTTP-x2F-2-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-nav-text">来自 HTTP&#x2F;2 的优化</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E6%9D%A5%E8%87%AA-HTTP-x2F-3-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-nav-text">来自 HTTP&#x2F;3 的优化</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#HTTP-x2F-1-1-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-nav-text">HTTP&#x2F;1.1 优缺点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-nav-text">缺点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#HTTP-x2F-1-1-%E6%80%A7%E8%83%BD%EF%BC%88%E5%AF%B9%E6%AF%94-HTTP-x2F-1-0%EF%BC%89"><span class="toc-nav-text">HTTP&#x2F;1.1 性能（对比 HTTP&#x2F;1.0）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-nav-text">长连接</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-nav-text">管道网络传输</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#HTTP-x2F-1-1-%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-nav-text">HTTP&#x2F;1.1 优化技术</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-nav-text">优化思路</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-nav-text">缓存技术</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-nav-text">强制缓存</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-nav-text">协商缓存</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E3%80%81%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81"><span class="toc-nav-text">减少重定向、请求合并、延迟发送</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-nav-text">压缩</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://by-yanxx.github.io/2023/03/01/HTTP 速览/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    <p>Stay hungry. Stay foolish.</p>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>