<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Stay hungry. Stay foolish.">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Redis 速通 | yby&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>yby's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">发现</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">发现</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Redis 速通</h2>
  <p class="post-date">2023-04-02</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是一种<code>基于内存</code>的开源数据库，读写操作都是在内存中完成，所以读写速度非常快，常用于<code>缓存</code>、<code>消息队列</code>、<code>分布式锁</code>等场景。</p>
<p>提供多种数据类型：<code>String（字符串）</code>、<code>Hash（哈希）</code>、<code>List（列表）</code>、<code>Set（集合）</code>、<code>ZSet（有序集合）</code>、<code>Bitmaps（位图）</code>、<code>HyperLogLog（基数统计）</code>、<code>GEO（地理信息）</code>、<code>Stream（流）</code>。</p>
<p>对数据类型的操作都由&#x3D;&#x3D;单线程完成，是原子性的，无并发问题&#x3D;&#x3D;。</p>
<p>支持<code>事务</code>、<code>持久化</code>、<code>Lua 脚本</code>、<code>多种集群方案（主从一致、哨兵、切片机集群）</code>、<code>发布/订阅模式</code>、<code>内存淘汰机制</code>、<code>过期删除机制</code>等。</p>
<h2 id="Redis-和-Memcached-区别"><a href="#Redis-和-Memcached-区别" class="headerlink" title="Redis 和 Memcached 区别"></a>Redis 和 Memcached 区别</h2><p><code>共同点</code>：</p>
<ul>
<li>都是基于内存的数据库，都被用来当缓存</li>
<li>都有过期策略</li>
<li>性能都很高</li>
</ul>
<p><code>区别</code>：</p>
<ul>
<li>Redis 支持的数据类型更丰富；Memcached 只支持 &lt;key-value&gt; 数据类型</li>
<li>Redis 有持久化功能，可将内存中的数据保存在磁盘上；Memcached 没有持久化功能，重启电脑，数据全无</li>
<li>Redis 原生支持集群模式；Memcached 无集群模式</li>
<li>Redis 支持发布&#x2F;订阅模式、Lua 脚本、事务等功能；Memcached 则不支持</li>
</ul>
<h2 id="为什么要用-Redis"><a href="#为什么要用-Redis" class="headerlink" title="为什么要用 Redis"></a>为什么要用 Redis</h2><p>为什么要用 Redis 作为 MySQL 的缓存？</p>
<p>因为 Redis 的「高性能」与「高并发」两特性。</p>
<ul>
<li><code>高性能</code>：对数据库内存的访问速度没有对缓存的访问快，操作 Redis 就是直接操作内存<ul>
<li><code>不足</code>：数据库中数据发生变化，需要同步修改 Redis，发生双写一致性问题</li>
</ul>
</li>
<li><code>高并发</code>：处理速度远大于 MySQL，能承受更大的请求压力，某些场景下可以将数据库中的部分数据存放在 Redis 里</li>
</ul>
<h1 id="常见面试题速览"><a href="#常见面试题速览" class="headerlink" title="常见面试题速览"></a>常见面试题速览</h1><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="有哪些数据类型、使用场景？"><a href="#有哪些数据类型、使用场景？" class="headerlink" title="有哪些数据类型、使用场景？"></a>有哪些数据类型、使用场景？</h3><p>常见的有五种数据类型，及其使用场景：</p>
<ul>
<li><p><code>String（字符串）</code>：缓存对象、常规计数、分布式锁、共享 session 等信息</p>
</li>
<li><p><code>Hash（哈希）</code>：缓存对象、购物车</p>
</li>
<li><p><code>List（列表）</code>：消息队列（存在两个问题：1. 生产者需要自行生成全局唯一 id；2. 不能以消费组的形式消费数据）</p>
<ul>
<li><blockquote>
<p>如何保证消息有序？：List 本身就是先入先出的顺序。</p>
<p>额外开销如何处理？：List 作为消息队列时，生产者不会通知消费者数据的写入，消费者需要不断调用读取方法，尝试消费消息队列里的消息，如果消息队列里没有内容，则消费者空转，带来性能消耗。解决：阻塞式读取，客户端没有读到队列数据时自动阻塞，有新数据存入消息队列时，消费者才开始读取新数据。</p>
<p>重复消息如何处理？：每个消息有唯一全局 id，消费者比对读取的消息 id 和已处理的消息的 id 来判断消息是否已处理。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>Set（集合）</code>：聚合计算（并集、交集、差集），如：点赞、关注、抽奖等</p>
</li>
<li><p><code>ZSet（有序集合）</code>：排序场景，如：排行榜、电话和姓名排序等</p>
</li>
</ul>
<p>后来，又支持四种数据类型：</p>
<ul>
<li><code>BitMap（位图）</code>：二值状态统计场景，如：签到、判断用户的登录状态</li>
<li><code>HyperLogLog（基数统计）</code>：海量数据的基数统计，如：网站 UV 统计</li>
<li><code>GEO（地理信息）</code>：存储地理位置信息，如：滴滴打车</li>
<li><code>Stream（流）</code>：消息队列（解决了 List 的两个问题：1. 可以自动生成全局唯一 id；2. 支持以消费组的形式消费数据）</li>
</ul>
<h3 id="五种常见的数据类型是如何实现的？"><a href="#五种常见的数据类型是如何实现的？" class="headerlink" title="五种常见的数据类型是如何实现的？"></a>五种常见的数据类型是如何实现的？</h3><img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402151735558.png" alt="image-20230402151735558" style="zoom:40%;">

<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p><code>数据结构</code>：「SDS（简单动态字符串）」</p>
</li>
<li><p>SDS 有如下特点：</p>
<ul>
<li><p>不仅可以保存文本数据，也可以保存&#x3D;&#x3D;二进制数据&#x3D;&#x3D;，也就是说可以保存图片、视频、音频等信息</p>
</li>
<li><p>获取字符串长度的时间复杂度是 &#x3D;&#x3D;O(1)&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;API 安全&#x3D;&#x3D;，拼接字符串不会溢出，因为拼接之前会去检查空间是否足够，不足时会扩容</p>
</li>
</ul>
</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>数据结构</code>：Redis3.0 时用的「双向链表」或「压缩列表」，最新版本用的「quicklist」</li>
<li>使用：<ul>
<li>如果元素个数小于 512 个（默认值），每个元素小于 64 字节（默认值），Redis 使用「压缩列表」作为 List 的数据结构</li>
<li>否则使用「双向链表」</li>
<li>Redis3.2 之后一律使用「quicklist」</li>
</ul>
</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul>
<li><code>数据结构</code>：Redis3.0 时用的「压缩列表」或「哈希表」，最新版本用的「listpack」或「哈希表」</li>
<li>使用：和 List 很像<ul>
<li>元素个数小于 512 个（默认值），所有值小于 64 字节（默认值），使用「压缩列表」</li>
<li>否则使用「哈希表」</li>
<li>最新版本中实用「listpack」代替「压缩列表」</li>
</ul>
</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>数据结构</code>：「哈希表」或「整数集合」</li>
<li>使用：<ul>
<li>元素均为整数，元素个数小于 512 个（默认值），使用「整数集合」</li>
<li>否则使用「哈希表」</li>
</ul>
</li>
</ul>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><ul>
<li><code>数据结构</code>：Redis3.0 时用的「压缩列表」或「跳表」，最新版本用的「listpack」或「跳表」</li>
<li>使用：<ul>
<li>有序集合的元素个数小于 128 个，每个元素值小于 64 字节，使用「压缩列表」</li>
<li>否则使用「跳表」</li>
<li>最新版本中使用「listpack」代替「压缩列表」</li>
</ul>
</li>
</ul>
<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="Redis-的单线程"><a href="#Redis-的单线程" class="headerlink" title="Redis 的单线程"></a>Redis 的单线程</h3><p>Redis 的单线程指的是&#x3D;&#x3D;「接收客户端请求 —&gt; 解析请求 —&gt; 处理请求 —&gt; 响应请求」这一过程是单线程的&#x3D;&#x3D;。</p>
<p>但 Redis 程序并不是单线程的，Redis 启动之后也会开启三个后台线程：</p>
<ul>
<li><code>BIO_CLOSE_FILE</code>：关闭文件</li>
<li><code>BIO_AOF_FSYNC</code>：AOF 刷盘</li>
<li><code>BIO_LAZY_FREE</code>：异步释放内存</li>
</ul>
<p>当客户端发出「关闭文件、AOF 刷盘或释放内存」的请求时，如果将其放在主线程里执行，会因为这三个任务都比较耗时导致阻塞，所以将这三个任务扔到任务队列中，由 BIO 不断轮询处理队列中的任务。</p>
<h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h3><ul>
<li><code>内存中执行 + 高效的数据结构</code>：Redis 的瓶颈在于「网络带宽」或「内存大小」，而非 CPU</li>
<li><code>单线程</code>：没有使用多线程，也就避免了「线程切换开销」和「死锁问题」</li>
<li><code>I/O 多路复用机制</code>：一个线程处理多个 IO 流，即「select&#x2F;epoll 机制」</li>
</ul>
<h3 id="为什么引入多线程？"><a href="#为什么引入多线程？" class="headerlink" title="为什么引入多线程？"></a>为什么引入多线程？</h3><p>早期 Redis 的网络 I&#x2F;O 和执行命令都是单线程的，因为制约 Redis 的不在于 CPU，而在于网络 I&#x2F;O 与计算机内存大小。</p>
<p>随着网络硬件的进步，内存的扩大，Redis 的性能瓶颈主要在「网络 I&#x2F;O」的处理上，所以在 Redis6.0 之后，&#x3D;&#x3D;使用多线程来处理网络 I&#x2F;O，但执行命令依旧是用单线程&#x3D;&#x3D;。</p>
<p>默认情况下，I&#x2F;O 多线程只针对发送响应数据（write client socket），并不会处理读请求（read client socket）。</p>
<p>综上，开启 Redis 后，默认情况下，在主线程 <code>Redis-server</code> 之外，会额外创建 6 个线程：</p>
<ul>
<li><code>BIO_CLOSE_FILE</code>、<code>BIO_AOF_FSYNC</code>、<code>BIO_LAZY_FREE</code>：三个后台线程</li>
<li><code>IO_THD_1</code>、<code>IO_THD_2</code>、<code>IO_THD_3</code>：三个 I&#x2F;O 线程（io-threads 默认为 4，开启 3 个线程比较合适），负责分担网络 I&#x2F;O 压力</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="Redis-如何保证数据不丢失？"><a href="#Redis-如何保证数据不丢失？" class="headerlink" title="Redis 如何保证数据不丢失？"></a>Redis 如何保证数据不丢失？</h3><p>Redis 的读写操作都在内存中进行，如果重启 Redis，内存释放，数据便会丢失。所以，Redis 通过「持久化机制」将数据写入磁盘。</p>
<p>三种持久化方式：</p>
<ul>
<li><code>AOF 日志</code>：全称 Append Only File（追加日志文件），每执行一个「写操作」，也会把「执行命令」记录到一个文件中</li>
<li><code>RDB 快照</code>：全称 Redis Database Backup file（Redis 数据备份文件），将某一时刻的内存数据，以二进制的方式写入磁盘</li>
<li><code>混合持久化方式</code>：AOF + RDB</li>
</ul>
<h3 id="AOF-日志如何实现的？"><a href="#AOF-日志如何实现的？" class="headerlink" title="AOF 日志如何实现的？"></a>AOF 日志如何实现的？</h3><img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402160327538.png" alt="image-20230402160327538" style="zoom:40%;">

<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402160337007.png" alt="image-20230402160337007" style="zoom:50%;">





<h4 id="为什么要先执行命令，后将命令记录到日志？"><a href="#为什么要先执行命令，后将命令记录到日志？" class="headerlink" title="为什么要先执行命令，后将命令记录到日志？"></a>为什么要先执行命令，后将命令记录到日志？</h4><ul>
<li>好处：<ul>
<li><code>避免额外的检查开销</code>：如果不对执行命令进行检查就先写入日志中，一旦命令有误，那么在恢复时就会发生错误</li>
<li><code>不会阻塞当前命令</code>：记录命令到日志中这个操作也是在主线程中进行的，和当前命令是同步关系，所以先记录日志后执行命令会阻塞当前命令</li>
</ul>
</li>
<li>坏处：<ul>
<li><code>有数据丢失风险</code>：执行完写命令后，在记录日志之前发生宕机，数据丢失</li>
<li><code>可能阻塞其他命令</code>：将当前命令记录到日志中这一操作，虽然不会阻塞当前命令，但可能阻塞后续的命令</li>
</ul>
</li>
</ul>
<h4 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h4><blockquote>
<p>从执行命令到写入磁盘的顺序：</p>
<p>执行写命令 —&gt; 命令追加到 server.aof_buf 缓冲区<em>（还会写到 AOF 重写缓冲区，这个后面会讲）</em> —&gt; I&#x2F;O 系统调用 write()，将 aof_buf 缓冲区数据写入 AOF —&gt; 数据拷贝到内核缓冲区 page cache，等待写入磁盘 —&gt; （等待） —&gt; 真正地写入硬盘</p>
</blockquote>
<p>何时将内核缓冲区的数据真正地写入硬盘，由内核决定，这个决定策略（即写回策略）有三种：</p>
<ul>
<li><code>Always</code>：每次写操作执行完命令后，同步将 AOF 日志数据写回硬盘</li>
<li><code>Everysec</code>：先将数据写入 AOF 文件的内核缓冲区 page cache，然后每隔一秒将缓冲区中的数据写回硬盘</li>
<li><code>No</code>：不由  Redis 控制写回硬盘的时机，由操作系统控制写回时机，即，先将数据写入 AOF 文件的内核缓冲区，再由操作系统决定何时写回硬盘</li>
</ul>
<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402162615442.png" alt="image-20230402162615442" style="zoom:40%;">



<h4 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h4><p>不断地将写操作的执行命令追加到文件后面，日志文件不断变大，Redis 重启时恢复数据的时间也随之变长。为此，Redis 通过&#x3D;&#x3D;「AOF 重写机制」&#x3D;&#x3D;来解决这一问题，当 AOF 文件大小超过设定的阈值时，启动 AOF 重写机制，来压缩 AOF 文件。</p>
<blockquote>
<p>简单来说，就是扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志。</p>
</blockquote>
<p>比如：先执行了 <code>set name yby</code> 命令，后执行了 <code>set name yanxx</code> 命令，那么 AOF 日志中会有两条记录，分别对应这两个操作。重写 AOF 时，对于键值对 <code>&lt;name-yanxx&gt;</code> 来说，前一个键值对 <code>&lt;name-yby&gt;</code> 就是过期的，是可以删掉的，所以重写后内存中只保留 <code>&lt;name-yanxx&gt;</code> 这一个键值对，最后将其转为一条命令记录到重写日志中，实现压缩。<em>（这只是一条数据，其他多条数据也是依次执行这个过程。）</em></p>
<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402163805682.png" alt="image-20230402163805682" style="zoom:50%;">



<p>重写之后，覆盖原来的 AOF 日志文件即可。</p>
<h4 id="重写-AOF-日志过程？"><a href="#重写-AOF-日志过程？" class="headerlink" title="重写 AOF 日志过程？"></a>重写 AOF 日志过程？</h4><p>由后台&#x3D;&#x3D;子进程&#x3D;&#x3D; <code>bgrewriteaof</code> 完成。</p>
<p>好处：</p>
<ul>
<li><code>避免阻塞</code>：重写期间，主进程继续处理命令请求，由子进程完成可以避免阻塞</li>
<li><code>性能考虑</code>：由子进程完成，而不是线程，是出于性能的考虑。多线程之间共享内存，修改共享内存数据时需要加锁保证线程安全，导致性能降低。父进程和用来重写的子进程也会共享内存数据，但是以只读的方式共享，父进程或子进程对共享内存数据做出改动时，会发生&#x3D;&#x3D;「写时复制」&#x3D;&#x3D;，无需加锁即可保证数据安全</li>
</ul>
<p>重写过程：触发 AOF 重写机制，主进程创建用于重写的子进程，子进程拿到主进程数据的副本，对内存数据只读，逐一将内存数据的键值对转为一条命令，记录到新的 AOF 日志文件。</p>
<blockquote>
<p>在重写的过程中，主进程依然可以正常处理命令，那如果在重写 AOF 日志过程中，主进程修改了一个已存在的键值对，那么此时发生「写时复制」，导致这条数据在子进程和主进程中不一致，如何处理？</p>
<p>答：AOF 重写缓冲区。</p>
</blockquote>
<p>为解决数据不一致问题，Redis 设置了&#x3D;&#x3D;「AOF 重写缓冲区」&#x3D;&#x3D;，在创建 <code>bgrewriteaof</code> 子进程之后开始使用。</p>
<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402171812907.png" alt="image-20230402171812907" style="zoom:40%;">



<p>即，&#x3D;&#x3D;在重写 AOF 期间&#x3D;&#x3D;，主进程执行命令之后，会将命令写入「AOF 缓冲区」和「AOF 重写缓冲区」。子进程完成 AOF 重写工作后，向主进程发送一条信号，主进程收到信号后，调用信号处理函数，该函数主要完成两件事：</p>
<ol>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 文件中，使新旧两个 AOF 日志文件所保存的数据库状态一致</li>
<li>将新的 AOF 文件改名，覆盖现有 AOF 文件</li>
</ol>
<p>发现：Redis7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁<br>盘&#x3D;&#x3D;两次&#x3D;&#x3D;。</p>
<blockquote>
</blockquote>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><h2 id="Redis-过期删除与内存淘汰"><a href="#Redis-过期删除与内存淘汰" class="headerlink" title="Redis 过期删除与内存淘汰"></a>Redis 过期删除与内存淘汰</h2><h2 id="Redis-缓存设计"><a href="#Redis-缓存设计" class="headerlink" title="Redis 缓存设计"></a>Redis 缓存设计</h2><h2 id="Redis-实战"><a href="#Redis-实战" class="headerlink" title="Redis 实战"></a>Redis 实战</h2></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Redis" >
    <span class="tag-code">Redis</span>
  </a>

  <a href="/tags#数据库" >
    <span class="tag-code">数据库</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/04/02/testTypora/">
        <span class="nav-arrow">← </span>
        
          typora 测试文章
        
      </a>
    
    
      <a class="nav-right" href="/2023/04/02/test2/">
        
          test2
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Redis"><span class="toc-nav-text">Redis</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E7%AE%80%E4%BB%8B"><span class="toc-nav-text">Redis 简介</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E5%92%8C-Memcached-%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">Redis 和 Memcached 区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis"><span class="toc-nav-text">为什么要用 Redis</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E9%80%9F%E8%A7%88"><span class="toc-nav-text">常见面试题速览</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">Redis 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-nav-text">有哪些数据类型、使用场景？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">五种常见的数据类型是如何实现的？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#String"><span class="toc-nav-text">String</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#List"><span class="toc-nav-text">List</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Hash"><span class="toc-nav-text">Hash</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Set"><span class="toc-nav-text">Set</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ZSet"><span class="toc-nav-text">ZSet</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-nav-text">Redis 数据结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">Redis 线程模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-nav-text">Redis 的单线程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-nav-text">Redis 为什么这么快？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">为什么引入多线程？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-nav-text">Redis 持久化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-nav-text">Redis 如何保证数据不丢失？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">AOF 日志如何实现的？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%90%8E%E5%B0%86%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%E5%88%B0%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-nav-text">为什么要先执行命令，后将命令记录到日志？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#AOF-%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-nav-text">AOF 写回策略有几种？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E8%BF%87%E5%A4%A7%EF%BC%8C%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-nav-text">AOF 日志过大，会触发什么机制？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%87%8D%E5%86%99-AOF-%E6%97%A5%E5%BF%97%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">重写 AOF 日志过程？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-nav-text">Redis 集群</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-nav-text">Redis 过期删除与内存淘汰</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-nav-text">Redis 缓存设计</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E5%AE%9E%E6%88%98"><span class="toc-nav-text">Redis 实战</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://by-yanxx.github.io/2023/04/02/Redis 速通/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    <p>Stay hungry. Stay foolish.</p>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>