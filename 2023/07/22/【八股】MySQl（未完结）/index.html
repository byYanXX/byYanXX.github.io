<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Stay hungry. Stay foolish.">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      【八股】MySQl（未完结） | yby&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>yby's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">发现</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">发现</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>【八股】MySQl（未完结）</h2>
  <p class="post-date">2023-07-22</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="基础篇（待补充）"><a href="#基础篇（待补充）" class="headerlink" title="基础篇（待补充）"></a>基础篇（待补充）</h1><h3 id="1-执行一条-SELECT-发生了什么？"><a href="#1-执行一条-SELECT-发生了什么？" class="headerlink" title="1. 执行一条 SELECT 发生了什么？"></a>1. 执行一条 SELECT 发生了什么？</h3><ol>
<li>TCP 三次握手，与**<code>连接器</code>**创建连接，验证用户名和密码，读取用户权限；</li>
<li>以 &lt;key-value&gt; 的形式将查询结果保存到**<code>缓存</code>**，key 为查询语句，value 为对应的查询结果，MySQL8.0 移除该部分；</li>
<li>**<code>解析器</code>**解析 SQL 语句，先进行词法分析，识别关键字，构建语法树，再进行语法分析（字段、表存在与否不在这里进行判断）；</li>
<li>**<code>预处理器</code>**检查查询语句中的字段、表是否存在，并将 “*” 符号扩展为所有列；</li>
<li>**<code>优化器</code>**确定执行方案，基于查询成本选择索引；</li>
<li>**<code>执行器</code>**根据执行方案执行 select 语句，从存储引擎中读取数据返回给客户端。</li>
</ol>
<blockquote>
<p>【<strong>相关追问</strong>】：</p>
<ol>
<li><p>如何查看 MySQL 被多少个客户连接？</p>
<p> 执行 <strong><code>show processlist</code></strong> 命令，可以查看连接状态，Sleep 表示空闲连接状态，Query 表示查询状态。</p>
</li>
<li><p>空闲连接状态可以保持多久？</p>
<p> 由 <strong><code>wait_timeout</code></strong> 参数控制，默认最长 8 小时，超时则断开。也可以使用 <strong><code>kill connection + id</code></strong> 命令手动断开。<br> 断开后，客户端会在发起下一次请求时报 ERROR。</p>
</li>
<li><p>MySQL 连接数量限制？</p>
<p> 由 <strong><code>max_connections</code></strong> 参数控制，默认最多 151 个，超过则拒绝连接请求。</p>
</li>
<li><p>MySQL 长连接占用内存如何解决？</p>
<p> 定期断开连接，或客户端主动重连。</p>
</li>
<li><p>为什么要移除查询缓存？</p>
<p> 鸡肋。如果表发生更新，那么查询缓存就会被清空。如果很大的一个查询结果刚放入缓存中，还没被使用表就更新了，缓存没有起到应有的作用。</p>
</li>
<li><p>如何知道优化器选择了哪个索引？</p>
<p> 在查询语句之前添加 <strong><code>explain</code></strong> 命令，查看执行计划表中的 **<code>key</code>**。如果是 PRIMARY 就表示使用了主键索引；如果是 NULL 就是全表扫描；如果有二级索引，那么 <strong><code>Extra</code></strong> 为 Using index 时就表示优化器选择了覆盖索引。</p>
</li>
</ol>
</blockquote>
<h3 id="2-表空间文件结构？"><a href="#2-表空间文件结构？" class="headerlink" title="2. 表空间文件结构？"></a>2. 表空间文件结构？</h3><p>**<code>段、区、页、行</code>**。</p>
<ul>
<li>每条记录按「行」存储，不同的行格式，有不同的存储结构；</li>
<li>数据库读取以「页」为单位，默认一页 16KB，分为数据页、溢出页、日志页；</li>
<li>表中数据量比较大时，相邻的两个页的物理位置并不连续，会出现大量随机 I&#x2F;O，会很慢，将连续的几个页放到一个「区」里面，使得相邻的两个页的物理位置也能够相邻，从而顺序 I&#x2F;O。默认一个区 1MB，即 64 个 16KB 的页；</li>
<li>「段」分为数据段（B+ 树叶子节点）、索引段（B+ 树非叶子节点）、回滚段（MVCC）等。</li>
</ul>
<h3 id="3-一条记录的存储结构？（InnoDB-行格式）"><a href="#3-一条记录的存储结构？（InnoDB-行格式）" class="headerlink" title="3. 一条记录的存储结构？（InnoDB 行格式）"></a>3. 一条记录的存储结构？（InnoDB 行格式）</h3><p>四种行格式：</p>
<ul>
<li>Redundant：古老版本，基本不用</li>
<li>Compact：MySQL5.1 默认行格式；</li>
<li>Dynamic：基于 Compact 行格式的改进，MySQL5.7 之后默认行格式</li>
<li>Compressed：也是基于 Compact 行格式的改进</li>
</ul>
<h3 id="4-⌛️-COMPACT-行格式？"><a href="#4-⌛️-COMPACT-行格式？" class="headerlink" title="4. ⌛️ COMPACT 行格式？"></a>4. ⌛️ COMPACT 行格式？</h3><p><img src="/../pictures/image-20230722153207967.png" alt="image-20230722153207967"></p>
<h3 id="5-varchar-n-中-n-最大取值为多少？"><a href="#5-varchar-n-中-n-最大取值为多少？" class="headerlink" title="5. varchar(n) 中 n 最大取值为多少？"></a>5. varchar(n) 中 n 最大取值为多少？</h3><h3 id="6-行溢出后，MySQL-是怎么处理的？"><a href="#6-行溢出后，MySQL-是怎么处理的？" class="headerlink" title="6. 行溢出后，MySQL 是怎么处理的？"></a>6. 行溢出后，MySQL 是怎么处理的？</h3><h3 id="7-数据库三范式？"><a href="#7-数据库三范式？" class="headerlink" title="7. 数据库三范式？"></a>7. 数据库三范式？</h3><ul>
<li>1NF：确保每列都是**<code>不可拆分</code>**的。比如学生表（<u>学号</u>，姓名，性别，出生年月日），这里的出生年月日需要再分为三个字段；</li>
<li>2NF：在 1NF 的基础上，确保非主键列**<code>完全依赖于主键</code>**，而不是依赖于主键的一部分。比如成绩表（<u>学号</u>、<u>课程号</u>、姓名、学分），这里学分完全依赖于主键学号、课程号，但姓名只依赖于学号，而非课程号，即姓名字段部分依赖主键；</li>
<li>3NF：在 2NF 的基础上，确保非主键列**<code>不存在传递依赖</code>**。比如学生信息表（<u>学号</u>、姓名、年龄、学院编号、学院名称、学院电话），学院编号依赖于学号，学院名称和电话依赖于学院编号，出现传递依赖，即学院名称和电话依赖于学号。</li>
</ul>
<h3 id="8-关系型数据库和非关系型数据库区别？"><a href="#8-关系型数据库和非关系型数据库区别？" class="headerlink" title="8. 关系型数据库和非关系型数据库区别？"></a>8. 关系型数据库和非关系型数据库区别？</h3><h3 id="9-存储引擎比较？"><a href="#9-存储引擎比较？" class="headerlink" title="9. 存储引擎比较？"></a>9. 存储引擎比较？</h3><h1 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h1><h3 id="1-索引的分类？"><a href="#1-索引的分类？" class="headerlink" title="1. 索引的分类？"></a>1. 索引的分类？</h3><ul>
<li>数据结构：B+ 树索引、Hash 索引、FullText 索引；</li>
<li>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）；</li>
<li>字段特性：主键索引、唯一索引、普通索引、前缀索引；</li>
<li>字段个数：单列索引、联合索引。</li>
</ul>
<blockquote>
<p>【<strong>知识补充</strong>】：</p>
<ol>
<li>主键索引：B+ 树的叶子节点存**<code>真实数据</code>**，建立在主键上的索引，只有一个，不能为 NULL；</li>
<li>二级索引：B+ 树叶子节点存**<code>索引值 + 主键值</code>**；</li>
<li>回表：通过二级索引查到主键值，后再从主键索引中找到真实数据的过程；</li>
<li>覆盖索引：通过二级索引就查询到目标数据，无需回表；</li>
<li>唯一索引：可以有多个，可以为 NULL，必须唯一；</li>
<li>前缀索引：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，**<code>减少索引占用空间</code>**；</li>
<li>联合索引：多个字段组成一个索引，需满足**<code>最左匹配原则</code>**。</li>
</ol>
</blockquote>
<h3 id="2-索引适用性？"><a href="#2-索引适用性？" class="headerlink" title="2. 索引适用性？"></a>2. 索引适用性？</h3><ul>
<li>索引缺点：<ul>
<li>**<code>占用物理空间</code>**；</li>
<li>索引的创建与维护**<code>耗时</code>**；</li>
<li>降低增删改操作的**<code>效率</code>**，每次操作时都需要动态维护索引的有序性。</li>
</ul>
</li>
<li>需要创建索引：<ul>
<li>字段的唯一性要求，如学号；</li>
<li>常用于 where 关键字的字段，如果字段不唯一，还可以用联合索引；</li>
<li>常用于 group by 或 order by 的字段，索引是已排序好的，无需再次排序。</li>
</ul>
</li>
<li>不需要创建索引：<ul>
<li>**<code>起不到定位作用</code>**的字段，不建议设为索引，因为索引会占用物理空间；</li>
<li>字段中有**<code>大量重复</code>**数据，特别地，优化器在发现某个值在表的数据行中占比很高的时候，会忽略索引，进行全表扫描；</li>
<li>表中**<code>数据太少</code>**；</li>
<li>**<code>经常改动</code>**的字段，因为需要维护 B+ 树的有序性，频繁重建索引，开销太大。</li>
</ul>
</li>
</ul>
<h3 id="3-索引的数据结构？其他的为何不行？"><a href="#3-索引的数据结构？其他的为何不行？" class="headerlink" title="3. 索引的数据结构？其他的为何不行？"></a>3. 索引的数据结构？其他的为何不行？</h3><p>B+ 树。</p>
<p>设计思路：考虑两个方面，一个是增删改的时间复杂度，一个是磁盘 I&#x2F;O 操作的次数。I&#x2F;O 操作越少，查询速度越快。</p>
<p>提出需求：每个节点可以存多个数据，每个节点可以有多个子节点，时间复杂度 O(nlgn)，更快地范围查询。</p>
<p>对比：</p>
<ul>
<li><p>哈希表：查询效率为 O(1)，但因**<code>数据无序</code>**，不适合范围查询；</p>
</li>
<li><p>二分查找树：二分查找，最坏情况是每次插入的元素都是最大值，二分查找树**<code>退化为链表</code>**；</p>
</li>
<li><p>自平衡二叉树（AVL）：查询效率为 O(lgn)，每个节点**<code>只有两个子节点</code><strong>，数据量增加，</strong><code>树会越来越高</code>**，而树存储在磁盘中，访问每个节点都对应一次 I&#x2F;O 操作，即树高决定了 I&#x2F;O 操作的次数，树太高，影响性能；</p>
</li>
<li><p>红黑树：一个节点**<code>只能存一个值</code><strong>，数据量增加，</strong><code>树也会越来越高</code><strong>，而且旋转</strong><code>操作复杂</code>**；</p>
</li>
<li><p>B 树：每个节点**<code>包含索引和真实数据</code>**，增删操作需要维护树的形状，效率低。范围查询需要中序遍历，涉及多个节点的磁盘 I&#x2F;O 操作，效率低；</p>
</li>
<li><p>B+ 树：</p>
<ul>
<li>**<code>非叶子节点只存索引</code>**，所以 B+ 树的非叶子节点可以存更多的索引，相同数据量下与 B 树相比 I&#x2F;O 次数更少；</li>
<li>非叶子节点中可以存放多个索引，这些索引字段在叶子节点中还会出现，在增删操作时，不会发生复杂的树的**<code>变形</code>**；</li>
<li>叶子节点之间由**<code>链表</code>**连接，适合范围查询。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【知识补充】：</p>
<ol>
<li><p>B 树：一个 M 阶 B 树，表示每个节点最多有 M - 1 个子节点，子节点个数超出范围后，会改变树的形状来维护 B 树。所以增删操作在一定程度上会影响 B 树形状的改变，进而影响性能。</p>
</li>
<li><p>InnoDB 的 B+ 树：叶子节点间使用的是**<code>双向链表</code><strong>，其节点内容是</strong><code>数据页</code>**，存放记录等信息，默认 16KB；</p>
</li>
<li><p>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。</p>
</li>
</ol>
</blockquote>
<h3 id="4-索引优化的方法？"><a href="#4-索引优化的方法？" class="headerlink" title="4. 索引优化的方法？"></a>4. 索引优化的方法？</h3><p>使用如下方法：</p>
<ul>
<li>**<code>前缀索引</code>**：使用字符串的前几个字符建立索引，但 order by 无法使用前缀索引，前缀索引不能作为覆盖索引，即需要回表操作；</li>
<li>**<code>覆盖索引</code><strong>：建立联合索引，尽量在二级索引中找到目标数据，</strong><code>避免回表</code>**；</li>
<li>主键**<code>自增</code>**：对于非自增主键，索引值随机，而为了满足数据有序，可能还需移动其他数据，即页分裂，造成内存碎片，索引结构不紧凑，查询效率低；</li>
<li>索引设置为 **<code>NOT NULL</code>**：允许为 NULL 则至少会用 1 字节空间存储 NULL 值列表，而且索引选择更复杂，难以优化；</li>
<li>**<code>防止索引失效</code>**。</li>
</ul>
<blockquote>
<p>【<strong>相关追问</strong>】：</p>
<ol>
<li><p>什么时候会发生索引失效？</p>
<ul>
<li><p>使用 <strong><code>select *</code></strong> 进行查询;</p>
</li>
<li><p>联合索引未遵循**<code>最左前缀匹配原则</code>**；</p>
</li>
<li><p>索引使用**<code>左模糊</code><strong>或</strong><code>左右模糊</code>**匹配，比如 <code>like &#39;%abc&#39;</code>：</p>
<ul>
<li><p>使用 like “%x”，索引一定会失效而走全表扫描吗？</p>
<p>  不一定，关键还是看数据表中的字段。如果数据库表中的字段只有主键 + 二级索引，即使使用了左模糊匹配，也不会走全表扫描，而是走全扫描二级索引树。</p>
</li>
</ul>
</li>
<li><p>索引使用**<code>函数</code><strong>或进行</strong><code>表达式计算</code>**：</p>
<ul>
<li>聚合函数：AVG(); SUM(); MAX(); MIN(); COUNT()；</li>
<li>其他函数：CAST(&lt;某个索引&gt; AS double)。</li>
</ul>
</li>
<li><p>索引发生**<code>隐式类型转换</code>**；</p>
</li>
<li><p>where 条件中使用 or，且 or 的前后条件中**<code>只要有一个列没有索引</code>**，涉及的索引都不会被使用到，即，需要保证 or 前后都是索引。</p>
</li>
</ul>
</li>
<li><p>什么是最左前缀匹配原则？</p>
<ul>
<li>使用**<code>联合索引</code>**时，MySQL 会根据联合索引中字段的前后顺序，从左到右依次到查询条件中去匹配，直到全部字段匹配完成。但是，如果遇到 &lt; 或 &gt; 这种范围查询，会停止匹配。特别地，对于 ≥、≤、between、like 前缀匹配的范围查询，并不会停止；</li>
<li>范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</li>
</ul>
</li>
<li><p>什么时候会发生隐式类型转换？隐式转换一定会造成索引失效么？</p>
<ul>
<li>操作符两端的**<code>数据类型不一致</code>**时，发生隐式类型转换；</li>
<li>操作符左边为**<code>数值</code><strong>类型时，隐式类型转换对效率</strong><code>影响不大</code>**，但不建议这么做；</li>
<li>操作符左边为**<code>字符</code><strong>类型时，隐式类型转换会导致</strong><code>索引失效</code>**，导致全表扫描，效率极低；</li>
<li>在字符串转为数值类型时，非数字开头的字符串会转为 0，以数字开头的字符串会截取第一个字符到第一个非数字内容为止。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="5-count-和-count-1-哪个性能更好？"><a href="#5-count-和-count-1-哪个性能更好？" class="headerlink" title="5. count(*) 和 count(1) 哪个性能更好？"></a>5. count(*) 和 count(1) 哪个性能更好？</h3><p>基本一样。</p>
<p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<h3 id="6-MySQL-自增主键一定是连续的吗？"><a href="#6-MySQL-自增主键一定是连续的吗？" class="headerlink" title="6. MySQL 自增主键一定是连续的吗？"></a>6. MySQL 自增主键一定是连续的吗？</h3><p>不一定：</p>
<ul>
<li>自增步长不为 1；</li>
<li>唯一键冲突；</li>
<li>事务回滚；</li>
<li>批量插入。</li>
</ul>
<h3 id="7-知道如何分析语句是否走索引查询？"><a href="#7-知道如何分析语句是否走索引查询？" class="headerlink" title="7. 知道如何分析语句是否走索引查询？"></a>7. 知道如何分析语句是否走索引查询？</h3><p>使用 EXPLAIN 命令。</p>
<p>从执行计划中的 key_len 字段就能知道是否走索引查询，因为该字段表示的是查询所用到的索引长度，再算一下你的多列索引总长度，对比一下就知道有没有使用到所有的列了。</p>
<blockquote>
<p>【相关追问】：</p>
<ol>
<li>EXPLAIN 字段有哪些？<ul>
<li>id：查询的序列标识符；</li>
<li>select_type：查询类型，SIMPLE</li>
<li>table：用到的表名；</li>
<li>partitions：匹配的分区，对于未分区的表，值为 NULL；</li>
<li>type：表的访问方法，type &#x3D; ALL 表示全表扫描，type &#x3D; index 表示扫描的是二级索引树；</li>
<li>possible_keys：可能用到的索引；</li>
<li>key：实际用到的索引，如果为 NULL，则表示未用到索引；</li>
<li>key_len：所选索引的长度，只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中，该字段的目的只是为了告诉你索引查询中用了哪些索引字段；</li>
<li>ref：使用索引等值查询时，与索引作比较的列或常量，ref &#x3D; const 时表示和常量做等值比较；</li>
<li>rows：预计要读取的行数；</li>
<li>filtered：按表条件过滤后，留存的记录数的百分比；</li>
<li>Extra：附加信息，Extra &#x3D; Using index 说明用上了覆盖索引，Extra &#x3D; Using index condition 说明用上了索引下推。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>【知识补充】：</p>
<ol>
<li>索引下推：从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</li>
</ol>
</blockquote>
<h3 id="8-判断哪些字段使用了联合索引？"><a href="#8-判断哪些字段使用了联合索引？" class="headerlink" title="8. 判断哪些字段使用了联合索引？"></a>8. 判断哪些字段使用了联合索引？</h3><ol>
<li>select * from t_table where a &gt; 1 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？<br> 只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。</li>
<li>select * from t_table where a &gt;&#x3D; 1 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？<br> 从符合 a &#x3D; 1 and b &#x3D; 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。所以，这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。</li>
<li>select * from t_table where a between 2 and 8 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？<br> a 和 b 字段都用到了联合索引进行索引查询。</li>
<li>select * from t_user where name like ‘j%’ and age &#x3D; 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？<br> a 和 b 字段都用到了联合索引进行索引查询。</li>
</ol>
<h2 id="索引篇总结"><a href="#索引篇总结" class="headerlink" title="索引篇总结"></a>索引篇总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[索引篇]--&gt;B[分类]</span><br><span class="line">A--&gt;C[适用性]</span><br><span class="line">C--&gt;F[优化]</span><br><span class="line">F--&gt;G[索引失效, key_len]</span><br><span class="line">G--&gt;H[最左匹配]</span><br><span class="line">G--&gt;I[隐式转换]</span><br><span class="line">G--&gt;J[EXPLAIN]</span><br><span class="line">G--&gt;L[案例判断]</span><br><span class="line">A--&gt;D[数据结构]</span><br><span class="line">D--&gt;K[对比]</span><br><span class="line">A--&gt;E[其他]</span><br><span class="line">E--&gt;M[未整理// 从数据页的角度看 B+ 树]</span><br></pre></td></tr></table></figure>



<h1 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h1><h3 id="1-事务的特性有哪些？如何实现的？"><a href="#1-事务的特性有哪些？如何实现的？" class="headerlink" title="1. 事务的特性有哪些？如何实现的？"></a>1. 事务的特性有哪些？如何实现的？</h3><p>事务由 InnoDB 引擎实现：</p>
<ul>
<li>原子性（A）：一系列操作**<code>要么全完成，要么全部不完成</code>**，如果中间出现错误，则直接回滚到事务开始时的状态；</li>
<li>一致性（C）：事务操作前后，数据满足完整性约束，数据库保持一致性状态，有点像**<code>能量守恒</code>**；</li>
<li>隔离性（I）：多个事务**<code>并发</code>**执行时，不会因交叉执行而导致数据不一致；</li>
<li>持久性（D）：事务处理结束后，对数据的**<code>修改是永久的</code>**，即使系统故障了也不会丢失。</li>
</ul>
<p>四种特性的实现：</p>
<ul>
<li>原子性保证：undo log（回滚日志）；</li>
<li>一致性保证：通过持久性 + 原子性 + 隔离性，共同保证；</li>
<li>隔离性保证：MVCC（多版本并发控制，由 ReadView + undo log 实现）或锁机制；</li>
<li>持久性保证：redo log（重做日志）。</li>
</ul>
<blockquote>
<p>【知识补充】：</p>
<ol>
<li>MyISAM 引擎不支持事务。</li>
</ol>
</blockquote>
<h3 id="2-并行事务会引发什么问题？什么是脏读？幻读？不可重复读？"><a href="#2-并行事务会引发什么问题？什么是脏读？幻读？不可重复读？" class="headerlink" title="2. 并行事务会引发什么问题？什么是脏读？幻读？不可重复读？"></a>2. 并行事务会引发什么问题？什么是脏读？幻读？不可重复读？</h3><ul>
<li>脏读：一个事务读到了另一个**<code>未提交事务修改过的数据</code>**；</li>
<li>幻读：在同一个事务内，多次查询符合条件的**<code>记录数量</code>**，出现记录数量前后不一致的情况；</li>
<li>不可重复读：在同一个事务内，多次读取同一个**<code>数据</code>**，出现数据前后不一致的情况。</li>
</ul>
<h3 id="3-事务状态有哪些？"><a href="#3-事务状态有哪些？" class="headerlink" title="3. 事务状态有哪些？"></a>3. 事务状态有哪些？</h3><ul>
<li>活动状态：事务正在执行，尚未提交或回滚；</li>
<li>部分提交状态：事务执行完毕，已提交到日志，但尚未提交到数据库；</li>
<li>失败状态：事务执行失败，需要回滚到开始状态；</li>
<li>回滚状态：事务回滚到开始状态；</li>
<li>已提交状态：事务执行成功，并已提交到数据库。</li>
</ul>
<h3 id="4-事务的隔离级别有哪些？如何实现的？"><a href="#4-事务的隔离级别有哪些？如何实现的？" class="headerlink" title="4. 事务的隔离级别有哪些？如何实现的？"></a>4. 事务的隔离级别有哪些？如何实现的？</h3><p>四种隔离级别：</p>
<ul>
<li>读未提交：事务**<code>尚未提交</code>**时，其做出的变更可以被其他事务看到；</li>
<li>读已提交：事务**<code>提交之后</code>**，其做出的变更才可以被其他事务看到；</li>
<li>可重复读：事务执行过程中看到的数据，和事务开始时的**<code>数据是一致的</code><strong>，InnoDB 引擎</strong><code>默认的隔离界别</code>**；</li>
<li>串行化：对记录**<code>加读写锁</code>**，如果发生读写冲突，那么后来的事务需要等待前一个事务结束才能开始执行。</li>
</ul>
<p>四种隔离级别的实现：</p>
<ul>
<li>读未提交：**<code>直接读</code>**取数据即可；</li>
<li>读已提交：通过 Read View 实现，在每个**<code>语句执行之前</code>**重新生成一个 Read View；</li>
<li>可重复读：通过 Read View 实现，在**<code>启动事务时</code>**生成一个 Read View，然后整个事务期间都使用该 Read View；</li>
<li>串行化：通过加**<code>读写锁</code>**实现，避免并行访问。</li>
</ul>
<h3 id="5-MVCC-的实现？"><a href="#5-MVCC-的实现？" class="headerlink" title="5. MVCC 的实现？"></a>5. MVCC 的实现？</h3><p>MVCC（多版本并发控制），由 Read View + undo log 实现：</p>
<ul>
<li>Read View 中有四个字段：<ul>
<li>m_ids：创建 Read View 时，当前数据库中**<code>活跃事务的 id 列表</code>**，活动事务指的是启动了但还没提交的事务；</li>
<li>min_trx_id：创建 Read View 时，当前数据库中活跃事务 id 列表中 **<code>id 最小的事务</code>**；</li>
<li>max_trx_id：创建 Read View 时，当前数据库中**<code>应该给下一个事务的 id 值</code>**，是活跃事务 id 列表中 id 最大值 + 1；</li>
<li>creator_trx_id：创建该 Read View 的事务的事务 id。</li>
</ul>
</li>
<li>聚簇索引记录中两个跟事务相关的“隐藏列”：<ul>
<li>trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的**<code>事务 id 记录在 trx_id</code>**；</li>
<li>roll_pointer：每次事务对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log 中，而 **<code>roll_pointer 则是一个指针，指向每一个旧版本记录</code>**，即，通过 roll_pointer 就可以找到修改前的旧记录。</li>
</ul>
</li>
</ul>
<p>MVCC 控制逻辑：</p>
<ul>
<li>如果 trx_id &lt; min_trx_id：表示该版本记录是由**<code>创建 Read View 之前已提交的事务</code>**生成的，所以该版本的记录对当前事务可见；</li>
<li>如果 trx_id ≥ max_trx_id：表示该版本记录是由**<code>创建 Read View 之后已提交的事务</code>**生成的，所以该版本的记录对当前事务不可见；</li>
<li>如果 min_trx_id &lt; trx_id &lt; max_trx_id，则需要判断 trx_id 是否在 m_ids（活跃事务 id 列表）中：<ul>
<li>如果 trx_id 在 m_ids 中：表示该版本记录的事务处于活跃状态，即，**<code>事务尚未提交</code>**，所以该版本的记录对当前事务不可见；</li>
<li>如果 trx_id 不在 m_ids 中：表示该版本记录的**<code>事务已提交</code>**，所以该版本的记录对当前事务可见。</li>
</ul>
</li>
</ul>
<p><em>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</em></p>
<h3 id="6-可重复读隔离界别如何解决幻读？"><a href="#6-可重复读隔离界别如何解决幻读？" class="headerlink" title="6. 可重复读隔离界别如何解决幻读？"></a>6. 可重复读隔离界别如何解决幻读？</h3><p>首先回顾幻读，指的是在同一个事务内，多次查询符合条件的**<code>记录数量</code>**，出现记录数量前后不一致的情况。</p>
<ul>
<li>针对快照读（普通 select 语句）：通过 <strong><code>MVCC</code></strong> 方式解决幻读。事务执行期间看到的数据和事务开始时是一致的，也就是说，执行期间增删数据都不会被察觉到，由此解决幻读问题；</li>
<li>针对当前读（select……for update 等语句）：通过**<code>临键锁</code>**（记录锁 + 间隙锁）解决幻读。在执行 select……for update 语句时，会加上临键锁，其他事务在想要插入数据时，会被阻塞，无法插入成功，由此解决幻读问题。</li>
</ul>
<blockquote>
<p>【知识补充】：</p>
<ol>
<li>select for update：<br> 是为了在查询时，对这条数据进行加锁，避免其他用户以该表进行插入，修改或删除等操作，造成表的不一致性。比如：select * from table for update 会等待行锁释放之后，返回查询结果。</li>
</ol>
</blockquote>
<blockquote>
<p>【相关追问】：</p>
<ol>
<li>幻读完全解决了吗？<br> 没有完全解决。</li>
</ol>
</blockquote>
<h2 id="事务篇总结"><a href="#事务篇总结" class="headerlink" title="事务篇总结"></a>事务篇总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[事务篇]--&gt;B[四大特性]</span><br><span class="line">B--&gt;B1[如何实现]</span><br><span class="line">A--&gt;C[事务并行]</span><br><span class="line">C--&gt;D[脏读]</span><br><span class="line">C--&gt;E[幻读]</span><br><span class="line">C--&gt;F[不可重复读]</span><br><span class="line">A--&gt;G[事务状态]</span><br><span class="line">A--&gt;H[四大隔离级别]</span><br><span class="line">H--&gt;I[如何实现]</span><br><span class="line">A--&gt;J[MVCC]</span><br><span class="line">J--&gt;K[Read View 四个字段 + undo log 隐藏列]</span><br></pre></td></tr></table></figure>



<h1 id="锁篇"><a href="#锁篇" class="headerlink" title="锁篇"></a>锁篇</h1><h3 id="1-有哪些锁？"><a href="#1-有哪些锁？" class="headerlink" title="1. 有哪些锁？"></a>1. 有哪些锁？</h3><ul>
<li>全局锁：整个数据库只读，主要用于备份，<code>flush tables with read lock</code> 与 <code>unlock tables</code>；</li>
<li>表级锁：<ul>
<li>表锁：不建议使用；</li>
<li>元数据锁（MDL）：对表进行 CRUD 操作时，加 MDL 读锁；表结构变更时，加 MDL 写锁。无需显式调用，**<code>事务提交后释放 MDL</code>**；</li>
<li>意向锁：对记录加共享锁之前，先在表级别上加意向共享锁；对记录加独占锁之前，现在表级别上加意向独占锁。这样以来，在加独占表锁时，就可以通过意向锁来判断是否有记录被加了独占锁，也就无需再去遍历表里记录了。意向锁的目的是用于**<code>快速判断</code>**表里是否有记录被加锁；</li>
<li>AUTO-INC 锁：插入数据时，可以自动给**<code>主键赋值递增</code>**，插入操作完成后立即释放，就是我们常用的 <code>AUTO_INCREMENT</code> 选项。</li>
</ul>
</li>
<li>行级锁：<ul>
<li>记录锁：仅锁住**<code>一条记录</code>**，防止其他事务同时操作该记录；</li>
<li>间隙锁：锁住**<code>一个范围</code><strong>，不包括范围边界两端的记录，只存在于可重复读隔离级别，主要是为了</strong><code>解决可重复读隔离级别下幻读</code><strong>的问题，特别地，间隙锁是</strong><code>兼容</code>**的，两个事务锁住的范围可以有交集；</li>
<li>临键锁：锁住**<code>一个范围</code><strong>，包括范围边界右端的记录，它是</strong><code>记录锁与间隙锁的结合</code><strong>，主要是为了</strong><code>防止其他事务在一个范围内插入新的记录</code>**，在能使用记录锁或者间隙锁就能避免幻读现象的场景下， 临键锁就会退化成退化成记录锁或间隙锁；</li>
<li>插入意向锁：不是意向锁，而是一种**<code>特殊的间隙锁</code><strong>，是轻量级锁，事务插入一条记录时会先判断插入位置是否被其他事务加了间隙锁，如果有，则阻塞等待间隙锁的释放，目的是</strong><code>表明有事务想在该区间插入新记录，但现在处于等待状态，没有真正获取锁</code>**，注意：<ul>
<li>间隙锁彼此兼容，但间隙锁和插入意向锁并**<code>不兼容</code><strong>，即，两个事务不能在同一时间内，一个拥有间隙锁，另一个拥有</strong>该间隙区间内**的插入意向锁；</li>
<li>间隙锁锁住的是一个区间，插入意向锁锁住的就是一个**<code>点</code>**。</li>
</ul>
</li>
</ul>
</li>
<li>共享锁和排他锁（表级锁和行级锁都有这两类）：<ul>
<li>共享锁（S 锁、读锁）：事务读取记录时获取共享锁，允许多个事务同时获取（锁兼容），SSS；</li>
<li>排他锁（X 锁、写锁、独占锁）：事务修改记录时获取排他锁，同一时间只能有一个事务获取此锁（锁不兼容），X。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【知识补充】</p>
<ol>
<li>那如果数据库有一个长事务，那在对表结构做变更操作的时候，可能会发生意想不到的事情？<ul>
<li>线程 A 先启用了事务，但是一直不提交，随后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li>
<li>线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞；</li>
<li>在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</li>
<li>【原因】：因为申请 MDL 锁的操作会形成一个队列，队列中**<code>写锁获取优先级高于读锁</code>**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</li>
<li>【解决】：在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，可以考虑 <strong><code>kill</code></strong> 掉这个长事务，然后再做表结构的变更。</li>
</ul>
</li>
<li>长事务：就是开启了事务，但是一直还没提交;</li>
<li>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的，但如果想加锁也是能加的；</li>
<li>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突；</li>
<li>MySQL 加锁流程：<ol>
<li><strong>设置锁结构</strong>：当一个事务请求锁（共享锁或排他锁）来访问某个数据时，MySQL 会为该事务创建一个锁结构，用于记录锁的相关信息，如事务 id、锁的类型等；</li>
<li><strong>设置锁等待状态</strong>：在设置锁结构后，MySQL 会将该锁的状态设置为等待状态。这意味着当前请求锁的事务**<code>尚未获取锁</code><strong>，但已经创建了锁结构，并且</strong><code>正在等待获取锁的机会</code>**；</li>
<li><strong>进入等待队列</strong>：在等待状态下，当前事务会进入**<code>等待队列</code>**，等待获取锁的机会。等待队列是一个管理等待锁的事务的队列。</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="2-表级锁和行级锁区别？"><a href="#2-表级锁和行级锁区别？" class="headerlink" title="2. 表级锁和行级锁区别？"></a>2. 表级锁和行级锁区别？</h3><ul>
<li>表级锁：粒度较大，针对非索引字段加的锁，对操作的整张表加锁，资源消耗少，加锁快，不会死锁，锁冲突概率高，和存储引擎无关；</li>
<li>行级锁：粒度最小，针对索引字段加的锁，对操作的行记录加锁，资源消耗大，加锁慢，会出现死锁，在存储引擎层面实现，InnoDB 引擎支持行级锁，MyISAM 引擎不支持行级锁。</li>
</ul>
<h3 id="3-update-没加索引会锁全表吗？"><a href="#3-update-没加索引会锁全表吗？" class="headerlink" title="3. update 没加索引会锁全表吗？"></a>3. update 没加索引会锁全表吗？</h3><h3 id="4-临键锁可以防止删除操作而导致的幻读吗？"><a href="#4-临键锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="4. 临键锁可以防止删除操作而导致的幻读吗？"></a>4. 临键锁可以防止删除操作而导致的幻读吗？</h3><p>可以。</p>
<h3 id="5-MySQL-死锁原因？如何避免？"><a href="#5-MySQL-死锁原因？如何避免？" class="headerlink" title="5. MySQL 死锁原因？如何避免？"></a>5. MySQL 死锁原因？如何避免？</h3><p><em>（死锁原因在 JUC 里面也有提到。）</em></p>
<h3 id="6-😅-MySQL-是怎么加行级锁的？"><a href="#6-😅-MySQL-是怎么加行级锁的？" class="headerlink" title="6. 😅 MySQL 是怎么加行级锁的？"></a>6. 😅 MySQL 是怎么加行级锁的？</h3></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#八股" >
    <span class="tag-code">八股</span>
  </a>

  <a href="/tags#mysql" >
    <span class="tag-code">mysql</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/07/22/%E3%80%90%E5%85%AB%E8%82%A1%E3%80%91%E8%AE%A1%E7%BD%91%EF%BC%88%E6%9C%AA%E5%AE%8C%E7%BB%93%EF%BC%89/">
        <span class="nav-arrow">← </span>
        
          【八股】计网（未完结）
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-nav-text">基础篇（待补充）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1-SELECT-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">1. 执行一条 SELECT 发生了什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-nav-text">2. 表空间文件结构？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9F%EF%BC%88InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F%EF%BC%89"><span class="toc-nav-text">3. 一条记录的存储结构？（InnoDB 行格式）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E2%8C%9B%EF%B8%8F-COMPACT-%E8%A1%8C%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="toc-nav-text">4. ⌛️ COMPACT 行格式？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-varchar-n-%E4%B8%AD-n-%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-nav-text">5. varchar(n) 中 n 最大取值为多少？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E8%A1%8C%E6%BA%A2%E5%87%BA%E5%90%8E%EF%BC%8CMySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">6. 行溢出后，MySQL 是怎么处理的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F"><span class="toc-nav-text">7. 数据库三范式？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">8. 关系型数据库和非关系型数据库区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-nav-text">9. 存储引擎比较？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AF%87"><span class="toc-nav-text">索引篇</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-nav-text">1. 索引的分类？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E7%B4%A2%E5%BC%95%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-nav-text">2. 索引适用性？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="toc-nav-text">3. 索引的数据结构？其他的为何不行？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-nav-text">4. 索引优化的方法？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-count-%E5%92%8C-count-1-%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="toc-nav-text">5. count(*) 和 count(1) 哪个性能更好？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-MySQL-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-nav-text">6. MySQL 自增主键一定是连续的吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%90%A6%E8%B5%B0%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-nav-text">7. 知道如何分析语句是否走索引查询？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-%E5%88%A4%E6%96%AD%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E4%BA%86%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-nav-text">8. 判断哪些字段使用了联合索引？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AF%87%E6%80%BB%E7%BB%93"><span class="toc-nav-text">索引篇总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-nav-text">事务篇</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">1. 事务的特性有哪些？如何实现的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%9F%E5%B9%BB%E8%AF%BB%EF%BC%9F%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F"><span class="toc-nav-text">2. 并行事务会引发什么问题？什么是脏读？幻读？不可重复读？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-nav-text">3. 事务状态有哪些？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">4. 事务的隔离级别有哪些？如何实现的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-nav-text">5. MVCC 的实现？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%95%8C%E5%88%AB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-nav-text">6. 可重复读隔离界别如何解决幻读？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AF%87%E6%80%BB%E7%BB%93"><span class="toc-nav-text">事务篇总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E9%94%81%E7%AF%87"><span class="toc-nav-text">锁篇</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="toc-nav-text">1. 有哪些锁？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">2. 表级锁和行级锁区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-update-%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-nav-text">3. update 没加索引会锁全表吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E4%B8%B4%E9%94%AE%E9%94%81%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97%EF%BC%9F"><span class="toc-nav-text">4. 临键锁可以防止删除操作而导致的幻读吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-MySQL-%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-nav-text">5. MySQL 死锁原因？如何避免？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%F0%9F%98%85-MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">6. 😅 MySQL 是怎么加行级锁的？</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://by-yanxx.github.io/2023/07/22/【八股】MySQl（未完结）/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    <p>Stay hungry. Stay foolish.</p>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>