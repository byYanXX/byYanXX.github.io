<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Stay hungry. Stay foolish.">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      【八股】计网（未完结） | yby&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>yby's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">发现</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">发现</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>【八股】计网（未完结）</h2>
  <p class="post-date">2023-07-22</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6932001161532669960#heading-9">参考链接</a></p>
<h1 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h1><h3 id="1-OSI-七层模型介绍一下？"><a href="#1-OSI-七层模型介绍一下？" class="headerlink" title="1. OSI 七层模型介绍一下？"></a>1. OSI 七层模型介绍一下？</h3><p>OSI 七层模型是开放式通信系统互连参考模型，是一套网络互连标准框架。<br>分为七层，从上至下依次是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<h3 id="2-OSI-七层模型中每层的作用？每层协议？"><a href="#2-OSI-七层模型中每层的作用？每层协议？" class="headerlink" title="2. OSI 七层模型中每层的作用？每层协议？"></a>2. OSI 七层模型中每层的作用？每层协议？</h3><ul>
<li>应用层：定义了应用进程之间的交互规则，为不同的应用提供服务，主要有 DNS、HTTP、SMTP 等协议；&#96;&#96;</li>
<li>表示层：**<code>数据处理</code>**，提供数据压缩、加密、描述等服务，目标是让应用程序无须担心在各计算机中的表示和存储的格式差异；</li>
<li>会话层：**<code>管理</code>**表示层实体之间的通话；</li>
<li>传输层：为两主机进程之间的通信提供通用的端到端的数据传输服务，主要有 TCP、UDP 等协议；</li>
<li>网络层：也叫 IP 层，主要是选择合适的路由和交换节点，即**<code>路由和寻址</code>**，主要有 IP、ICMP、IGMP、ARP 等协议；</li>
<li>数据链路层：将网络层的 IP 数据报**<code>封装成帧</code>**，定义了数据的基本格式；</li>
<li>物理层：透明传输比特流。</li>
</ul>
<h3 id="3-TCP-x2F-IP-四层模型和五层模型？"><a href="#3-TCP-x2F-IP-四层模型和五层模型？" class="headerlink" title="3. TCP&#x2F;IP 四层模型和五层模型？"></a>3. TCP&#x2F;IP 四层模型和五层模型？</h3><p>四层的话，依次是应用层、传输层、网络层、网络接口层。<br>五层的话，依次是应用层、传输层、网络层、数据链路层、物理层。</p>
<p>五层模型本质上还是基于 TCP&#x2F;IP 四层模型设计的。</p>
<h3 id="4-模型之间的数据是如何传输的？"><a href="#4-模型之间的数据是如何传输的？" class="headerlink" title="4. 模型之间的数据是如何传输的？"></a>4. 模型之间的数据是如何传输的？</h3><p>应用层**<code>报文</code>** —传送到—&gt;<br>传输层，头部添加上 TCP 头，构成**<code>报文段</code>** —传送到—&gt;<br>网络层，头部添加上 IP，构成**<code>数据报</code>** —传送到—&gt;<br>数据链路层，首尾添加发送端的 MAC 地址和接收端的 MAC 地址，封装成**<code>帧</code>** —传送到—&gt;<br>物理层，封装成**<code>比特流</code>** —通过传输介质，传送到—&gt; 另一端。</p>
<h3 id="5-为什么要去掉表示层和会话层？"><a href="#5-为什么要去掉表示层和会话层？" class="headerlink" title="5. 为什么要去掉表示层和会话层？"></a>5. 为什么要去掉表示层和会话层？</h3><p>应用层、表示层和会话层都是在应用程序内部实现的，最终生成的是一个数据包，程序之间几乎**<code>没有办法抽象</code>**出共享代码，导致这种分层无法实现。</p>
<h3 id="6-OSI-模型和-TCP-x2F-IP-模型之间的异同？"><a href="#6-OSI-模型和-TCP-x2F-IP-模型之间的异同？" class="headerlink" title="6. OSI 模型和 TCP&#x2F;IP 模型之间的异同？"></a>6. OSI 模型和 TCP&#x2F;IP 模型之间的异同？</h3><ul>
<li>相同点：<ul>
<li>都分层</li>
<li>都可以面向连接和无连接</li>
</ul>
</li>
<li>不同点：<ul>
<li>一个七层，一个四层；</li>
<li>OSI 先有的模型后有的协议规范，TCP&#x2F;IP 先有的协议后有的模型；</li>
<li>OSI 实现困难。</li>
</ul>
</li>
</ul>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-HTTP-头部包含哪些内容？"><a href="#1-HTTP-头部包含哪些内容？" class="headerlink" title="1. HTTP 头部包含哪些内容？"></a>1. HTTP 头部包含哪些内容？</h3><p>HTTP 头部主要是一些键值对。一般分为：通用头部、请求头部、响应头部、实体头部。</p>
<ul>
<li><p>通用头部：（不依赖请求或响应内容，一般不随消息内容的变化而变化）</p>
<ul>
<li><p>Cache-control：指定是否使用**<code>缓存</code>**机制</p>
</li>
<li><p>Connection：优先使用的连接类型，比如 keep-alive **<code>长连接</code>**；</p>
</li>
<li><p>Date：报文创建**<code>时间</code>**；</p>
</li>
<li><p>Warning：内容存在一些**<code>错误</code>**；</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
<li><p>请求头部：（客户端 —&gt; 服务端，描述客户端的需求和约束）</p>
<ul>
<li>Accept：告诉服务端浏览器自己允许的**<code>服务类型</code>**，比如 text&#x2F;plain；<ul>
<li>Accept-Charset：表明浏览器可接受的字符集；</li>
<li>Accept-Encoding：表明浏览器可接受的编码；</li>
<li>Accept-Language：表明浏览器可接受的语言；</li>
</ul>
</li>
<li>Host：服务器域名及服务器监听的**<code>端口号</code>**；</li>
<li>If-XXX：**<code>条件</code>**请求，比如 If-Modified-Since；</li>
<li>……</li>
</ul>
</li>
<li><p>响应头部：（服务端 —&gt; 客户端，描述响应信息）</p>
<ul>
<li>Age：创建响应的**<code>时间</code>**；</li>
<li>ETag：分配资源的**<code>唯一标识</code>**；</li>
<li>Location：**<code>重定向</code>**后的 URL；</li>
<li>Server：服务端信息；</li>
<li>……</li>
</ul>
</li>
<li><p>实体头部：（描述消息主体的信息）</p>
<ul>
<li>Allow：对资源的请求行为，比如 **<code>GET、HEAD</code>**；</li>
<li>Content-encoding：内容编码方式；</li>
<li>Content-Length：内容字节长度；</li>
<li>Content-Language：内容使用的语言；</li>
<li>Content-MD5：返回资源的 MD5 校验值；</li>
<li>Expires：响应的**<code>过期时间</code>**；</li>
<li>Last-Modified：请求资源**<code>最后修改时间</code>**；</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="2-⌛️-长连接-keep-alive-和短连接的区别？使用场景？"><a href="#2-⌛️-长连接-keep-alive-和短连接的区别？使用场景？" class="headerlink" title="2. ⌛️ 长连接 keep-alive 和短连接的区别？使用场景？"></a>2. ⌛️ 长连接 keep-alive 和短连接的区别？使用场景？</h3><h3 id="3-如何知道-HTTP-报文长度？"><a href="#3-如何知道-HTTP-报文长度？" class="headerlink" title="3. 如何知道 HTTP 报文长度？"></a>3. 如何知道 HTTP 报文长度？</h3><p>根据响应消息中的 <strong><code>Content-Length</code></strong> 字段。如果是一些资源是动态加载的，那么需要通过 **<code>Transfer-Encoding（分块传输编码）</code>**代替 Content-Length 字段来计算报文长度。</p>
<p>Transfer-Encoding 技术是 HTTP&#x2F;1.1 中引入的数据传输机制。服务端 —&gt; 客户端的数据分成多块，每一块都包含资源数据和长度值，特别地，最后一块长度值为 0，表示数据传输的结束。</p>
<h3 id="4-HTTP-请求方法有哪些？"><a href="#4-HTTP-请求方法有哪些？" class="headerlink" title="4. HTTP 请求方法有哪些？"></a>4. HTTP 请求方法有哪些？</h3><ul>
<li><p>HTTP&#x2F;1.0 提供三种请求：</p>
<ul>
<li>GET：请求指定页面信息，返回具体内容，用于**<code>读取数据</code>**；</li>
<li>HEAD：和 GET 同，但返回的响应中没有具体内容，用于**<code>获取报头</code>**；</li>
<li>POST：向目标资源**<code>提交</code>**数据进行处理。</li>
</ul>
</li>
<li><p>HTTP&#x2F;1.1 新加了六种请求：<em>（<u>联想记忆：PODTCP</u>）</em></p>
<ul>
<li>PUT：**<code>替换</code>**资源，若没有资源，则为新增；</li>
<li>OPTIONS：向服务器发送该方法，返回对指定资源支持的 **<code>HTTP 请求方法</code>**；</li>
<li>DELETE：请求服务器**<code>删除</code>** URL 标识的资源数据；</li>
<li>TRACE：服务器返回自己收到的数据，用于**<code>测试和诊断</code>**；</li>
<li>CONNECT：将服务器作为**<code>代理</code>**，代替用户发进行访问；</li>
<li>PATCH：**<code>PUT 方法的补充</code>**，对已知资源进行局部更新。</li>
</ul>
</li>
</ul>
<h3 id="5-GET-和-POST-区别？"><a href="#5-GET-和-POST-区别？" class="headerlink" title="5. GET 和 POST 区别？"></a>5. GET 和 POST 区别？</h3><ol>
<li>GET **<code>不安全</code>**，提交的数据会放在 URL 之后，完全暴露，且参数保留在浏览器里面，常用于获取资源；<br> POST 参数放在请求体中，且不会被保留，更安全，主要用于修改资源。</li>
<li>GET **<code>幂等的</code>**，多次请求得到的结果是一样的，不会对服务器造成影响；<br> POST 请求不是幂等的，多次请求可能会对服务器造成影响，因为它可能会导致服务器状态的改变。</li>
<li>GET 只支持 **<code>URL 编码</code>**；<br> POST 支持多种编码格式。</li>
<li>GET 只支持 **<code>ASCII 格式</code>**的参数；<br> POST 无限制。</li>
<li>GET 提交的**<code>数据大小</code>**有限制（比如：Chrome 浏览器的 URL 最大长度限制为 8182 个字符，FireFox 则是 65536 个）；<br> POST 无限制。</li>
<li>GET **<code>获取变量</code>**值使用 Request.QueryString 方法；<br> POST 使用 Request.Form 方法。</li>
<li>GET 产生一个 **<code>TCP 数据包</code>**，即浏览器将请求头和请求体一并发送出去，返回 200ok；<br> POST 在一些浏览器中会产生两个 TCP 数据包，即浏览器会先发送出请求头，服务器响应 100continue，然后再发送请求体，返回 200ok（特别地，FireFox 浏览器只会 POST 一个 TCP 数据包）。</li>
</ol>
<blockquote>
<p>【注意】：</p>
<p>关于二者的安全性与幂等性，按如下回答：</p>
<ul>
<li><p>从 RFC 规范定义的语义来分析：</p>
<p>  GET 方法就是**<code>安全且幂等</code><strong>的，因为它是「只读」操作；<br>  POST 方法</strong><code>不安全也不幂等</code>**，因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</p>
</li>
<li><p>但是！开发者不一定会按照 RFC 规范定义的语义来实现：</p>
<p>  可以用 **<code>GET 方法实现增删</code><strong>数据的请求，这样实现的 GET 方法自然就</strong><code>不是安全和幂等</code>**；<br>  可以用 **<code>POST 方法实现查询</code><strong>数据的请求，这样实现的 POST 方法自然就是</strong><code>安全和幂等</code>**。</p>
</li>
</ul>
<p>即，安全且幂等的是「只读」，不安全也不幂等的是「增删」。</p>
</blockquote>
<h3 id="6-状态码？"><a href="#6-状态码？" class="headerlink" title="6. 状态码？"></a>6. 状态码？</h3><ul>
<li>1XX：请求正在处理</li>
<li>2XX：成功<ul>
<li>200 ok：正常；</li>
<li>204 No Content：同 200ok，但没有消息体；</li>
<li>206：分块传输。</li>
</ul>
</li>
<li>3XX：重定向<ul>
<li>301：永久重定向，旧地址已删除；</li>
<li>302：临时重定向，旧地址还存在，临时跳转到一个新的 URL 地址，客户端应继续使用原有的 URI；</li>
<li>304：缓存重定向，用于缓存控制，表示资源在缓存中可以继续使用。</li>
</ul>
</li>
<li>4XX：客户端错误<ul>
<li>400：笼统的错误</li>
<li>403：资源禁止访问；</li>
<li>404：找不到请求资源。</li>
</ul>
</li>
<li>5XX：服务端错误<ul>
<li>500：笼统的错误；</li>
<li>501：资源不存在，仍在开发中；</li>
<li>502：网关或代理的服务器，从上游服务器中接收到的响应是无效；</li>
<li>503：繁忙，稍后再试。</li>
</ul>
</li>
</ul>
<h3 id="7-HTTP-x2F-1-1-缓存技术？"><a href="#7-HTTP-x2F-1-1-缓存技术？" class="headerlink" title="7. HTTP&#x2F;1.1 缓存技术？"></a>7. HTTP&#x2F;1.1 缓存技术？</h3><ol>
<li>【强制缓存】</li>
</ol>
<p>决定是否使用本地缓存的**<code>主动权在浏览器端</code>**，只要浏览器判断缓存没有过期，就直接使用浏览器的本地缓存。</p>
<p>实现方式：</p>
<ul>
<li>**<code>Cache-Control</code>**（优先级更高）：相对的过期时间；</li>
<li>**<code>Expires</code>**：绝对的过期时间。</li>
</ul>
<p>具体流程如下：</p>
<ul>
<li>浏览器在首次发送请求后，服务端响应资源时会在 HTTP 报文**<code>头部加上 Cache-Control</code>**；</li>
<li>当浏览器再次请求访问服务器中的该资源时，会先对比请求时间和过期时间，判断缓存资源**<code>是否过期</code>**：<ul>
<li>没过期，则强制使用缓存；</li>
<li>否则重新发送请求，后续根据判断进行协商缓存或者重新响应。</li>
</ul>
</li>
<li>服务端接收到请求后，**<code>更新</code>**头部（header）的 Cache-Control。</li>
</ul>
<ol start="2">
<li>【协商缓存】</li>
</ol>
<p>决定是否使用本地缓存的**<code>主动权在用户</code>**，浏览器判断缓存过期了，但资源内容没有改变，则向用户抛出选择，由用户决定是继续使用本地缓存还是重新请求资源。</p>
<p>两种实现方式：</p>
<ul>
<li>由**<code>请求头部的 If-Modified-Since</code>** 字段和**<code>响应头部的 Last-Modified</code>** 字段，**<code>基于时间来判断资源是否有改动</code>**：<ul>
<li>Last-Modified：标识响应资源最后修改时间</li>
<li>If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比：<ul>
<li>如果发现资源最后的修改时间更大（新），则说明资源有改动，提供最新的响应资源，响应 HTTP 200 OK</li>
<li>否则，可以说明资源虽然过期了，但缓存中的资源还没有被改动，则响应 HTTP 304 走本地缓存</li>
</ul>
</li>
</ul>
</li>
<li>由**<code>请求头部的 If-None-Match</code>** 字段和**<code>响应头部的 Etag</code>** 字段，**<code>基于一个唯一标识来判断资源是否有改动</code>**（优先级更高）：<ul>
<li>Etag：响应资源的唯一标识</li>
<li>If-None-Match：发现缓存过期时，浏览器将 If-None-Match 字段值设置为 Etag 值，服务端将来自浏览器的 Etag 值与服务端的 Etag 值进行对比：<ul>
<li>如果 Etag 不同，说明资源有改动，响应 HTTP 200 OK</li>
<li>如果 Etag 没变，说明资源没有改变，响应 HTTP 304 走缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>只有在未命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<blockquote>
<p>【相关追问】：</p>
<ol>
<li>为什么 Etag 优先级更高？<ul>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变；</li>
<li>可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ul>
</li>
</ol>
</blockquote>
<p>具体流程如下：（使用 Etag 方式）</p>
<ul>
<li>当浏览器首次请求访问服务器资源时，服务器会在返回这个资源的同时，在**<code>响应头部加上 ETag</code>** 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li>
<li>浏览器再次请求该资源时，**<code>先判断强制缓存是否过期</code>**<ul>
<li>如果没过期，则强制使用本地缓存，</li>
<li>否则会在请求头部加上 If-None-Match 字段（该字段的值就是第一次收到的响应消息中的 Etag 标识）。</li>
</ul>
</li>
<li>服务端接收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较，判断资源**<code>是否有改动</code>**：<ul>
<li>值相等，返回 304 Not Modified，走缓存；</li>
<li>值不等，返回 200ok 与最新资源，响应头部**<code>更新</code>**的 Etag 唯一标识。</li>
</ul>
</li>
<li>浏览器如果收到 304 的响应状态码，则从本地缓存中加载资源，否则更新资源。</li>
</ul>
<h3 id="8-如何减少-HTTP-请求次数？"><a href="#8-如何减少-HTTP-请求次数？" class="headerlink" title="8. 如何减少 HTTP 请求次数？"></a>8. 如何减少 HTTP 请求次数？</h3><ul>
<li>**<code>减少重定向的请求次数</code>**：将重定向的工作交由代理服务器完成；</li>
<li>**<code>请求合并</code>**：使用打包工具，将 js、css 等资源合并打包成大资源来代替多个小资源的请求；</li>
<li>**<code>延迟发送</code>**：按需获取，用户暂时访问不到的资源，没必要发出请求</li>
</ul>
<h2 id="HTTP-各版本对比"><a href="#HTTP-各版本对比" class="headerlink" title="HTTP 各版本对比"></a>HTTP 各版本对比</h2><h3 id="1-HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别？"><a href="#1-HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别？" class="headerlink" title="1. HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别？"></a>1. HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别？</h3><ul>
<li><p>缓存处理更灵活：</p>
<p>  HTTP&#x2F;1.0 中主要使用 header 里的 if-modified-Since、Expries 来做缓存判断的标准；<br>  HTTP&#x2F;1.1 请求头中添加了**<code>更多与缓存相关的字段</code>**，从而支持更为灵活的缓存策略，例如 Entity-tag、If-Unmodified-Since、If-Match、If-None-Match 等可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p>节约带宽： </p>
<p>  当客户端请求某个资源时，HTTP&#x2F;1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息；<br>  在 HTTP&#x2F;1.1 的请求头中引入了 range 头域，它**<code>允许只请求部分资源</code>**，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p>
</li>
<li><p>错误通知的管理：</p>
<p>  HTTP&#x2F;1.1 在 1.0 的基础上**<code>新增了 24 个错误状态响应码</code>**，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理，410 表示所请求的资源已经被永久删除。</p>
</li>
<li><p>Host 请求头：</p>
<p>  早期 HTTP&#x2F;1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址；<br>  为了**<code>支持虚拟主机</code><strong>，HTTP&#x2F;1.1 中</strong><code>添加了 host 请求头</code>**，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p>
</li>
<li><p>长连接：</p>
<p>  HTTP&#x2F;1.0 默认浏览器和服务器之间保持短连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接；<br>  HTTP&#x2F;1.1 **<code>默认长连接</code>**，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p>
</li>
</ul>
<h3 id="2-HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别？"><a href="#2-HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别？" class="headerlink" title="2. HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别？"></a>2. HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别？</h3><p>来自 HTTP&#x2F;2.0 的优化：</p>
<ul>
<li>基于 HTTPS，更**<code>安全</code>**；</li>
<li>通过 gzip 和 compress **<code>压缩头部</code><strong>，消除重复部分，客户端和服务端会共同维护一张拥有所有字段的</strong><code>头部信息表</code>**；</li>
<li>将 header 和 body 部分都变为**<code>二进制帧（Frame）</code>**，计算机直接识别二进制文件，更快、更有效率；</li>
<li>为解决响应队头阻塞的问题，使用「Stream」来解决。一个 Stream 里可以有多个 Message，一个 Message 里可以有多个 Frame，不同的请求其 StreamID 都不同，接收端再通过 StreamID 按序组装，所以**<code>可以乱序发送</code><strong>，实现了消息的</strong><code>并行发送，支持多路复用</code>**；</li>
<li>服务端可以向客户端**<code>主动推送</code>**消息，减少消息传递的次数。特别地，StreamID 上服务端为偶数，客户端为奇数。</li>
</ul>
<p>HTTP&#x2F;2.0 仍存在的不足：</p>
<ul>
<li>虽然解决了 HTTP&#x2F;1.1 响应队头阻塞问题，但因其基于 TCP 协议，所以收到的字节数据必须完整且连续，所以当 Stream 里某个字节数据丢失（丢包），后面的字节数据都会阻塞在内核缓冲区里，发生 **<code>TCP 队头阻塞</code>**。</li>
</ul>
<h3 id="3-⌛️-HTTP-x2F-3-了解吗？"><a href="#3-⌛️-HTTP-x2F-3-了解吗？" class="headerlink" title="3. ⌛️ HTTP&#x2F;3 了解吗？"></a>3. ⌛️ HTTP&#x2F;3 了解吗？</h3><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="1-⌛️-HTTPS-的工作流程-x2F-建立连接的过程？"><a href="#1-⌛️-HTTPS-的工作流程-x2F-建立连接的过程？" class="headerlink" title="1. ⌛️ HTTPS 的工作流程&#x2F;建立连接的过程？"></a>1. ⌛️ HTTPS 的工作流程&#x2F;建立连接的过程？</h3><blockquote>
<p> HTTPS 是在 HTTP 基础上通过传输加密和身份认证的方式保证传输过程的安全性。</p>
</blockquote>
<h3 id="2-HTTP-vs-HTTPS？"><a href="#2-HTTP-vs-HTTPS？" class="headerlink" title="2. HTTP vs HTTPS？"></a>2. HTTP vs HTTPS？</h3><ul>
<li>HTTP 明文传输，**<code>不安全</code>**；<br>  HTTPS 引入 SSL&#x2F;TLS 协议，加密传输。</li>
<li>HTTP 默认**<code>端口号</code>**为 80；<br>  HTTPS 为 443。</li>
<li>HTTP 响应**<code>更快</code>**，只需 TCP 三次握手；<br>  HTTPS 需要四次握手，即 SSL&#x2F;TLS 协商过程。</li>
<li>HTTP 的 <strong><code>URL</code></strong> 是 “http:&#x2F;&#x2F;”；<br>  HTTPS 是 “https:&#x2F;&#x2F;”。</li>
<li>HTTPS 需要从 <strong><code>CA</code></strong> 购买证书。</li>
</ul>
<h3 id="3-有哪些加密方式？HTTPS-的加密方式？"><a href="#3-有哪些加密方式？HTTPS-的加密方式？" class="headerlink" title="3. 有哪些加密方式？HTTPS 的加密方式？"></a>3. 有哪些加密方式？HTTPS 的加密方式？</h3><ul>
<li>单向加密：只能加密，不能解密；输入一样，输出一样，输入不同，输出不同</li>
<li>对称加密：加密和解密都用同一把密钥，速度快；</li>
<li>非对称加密：公钥加密，私钥解密，或者私钥加密，公钥解密，速度非常慢。<ul>
<li>**<code>公钥加密</code><strong>，私钥解密：用来加密</strong><code>内容</code>**；</li>
<li>**<code>私钥加密</code><strong>，公钥解密：用来验证</strong><code>身份</code>**。</li>
</ul>
</li>
</ul>
<p>HTTPS 采用**<code>对称加密和非对称加密结合</code>**的方式。</p>
<h3 id="4-HTTPS-实现安全传输的策略？"><a href="#4-HTTPS-实现安全传输的策略？" class="headerlink" title="4. HTTPS 实现安全传输的策略？"></a>4. HTTPS 实现安全传输的策略？</h3><ul>
<li>混合加密（保护会话密钥，解决明文传输不安全问题）；</li>
<li>摘要算法（原数据太大不方便加密，也不方便检验内容是否被篡改，通过摘要减小加密数据的大小） + 数字签名（防篡改）；</li>
<li>数字证书（保证公钥安全可靠，以防第三方骗子冒充服务端）。</li>
</ul>
<p><img src="/../pictures/image-20230414210006144.png" alt="image-20230414210006144"></p>
<h2 id="⌛️-其他"><a href="#⌛️-其他" class="headerlink" title="⌛️ 其他"></a>⌛️ 其他</h2><h3 id="URL-和-URI？"><a href="#URL-和-URI？" class="headerlink" title="URL 和 URI？"></a>URL 和 URI？</h3><p>URL 是 URI 的一个子集。</p>
<p><img src="/../pictures/image-20230722110505647.png" alt="image-20230722110505647"></p>
<h3 id="网页解析全过程？"><a href="#网页解析全过程？" class="headerlink" title="网页解析全过程？"></a>网页解析全过程？</h3><ol>
<li><code>URL 解析</code></li>
</ol>
<p>根据 URL 格式进行解析，确定 Web 服务器和文件名，生成 HTTP 请求消息。</p>
<ol start="2">
<li><code>DNS 查询</code></li>
</ol>
<p>操作系统将 HTTP 请求消息发送给 Web 服务器，再由 DNS（也就是域名服务器）查询服务器域名对应的 IP 地址。查询过程如下：</p>
<ul>
<li>浏览器搜索自身 DNS 缓存，如果有，则直接返回解析结果，否则查询操作系统的 DNS 缓存</li>
<li>搜索操作系统的 DNS 缓存，如果有，则直接返回解析结果，否则查询本地 Host 文件</li>
<li>读取本地 Host 文件，如果有，则直接返回解析结果，否则，否则</li>
<li>查询本地 DNS（递归查询）<ul>
<li>如果域名包含在本地 DNS 中，返回解析结果给客户端</li>
<li>如果域名不在本地 DNS 中，但服务器已缓存了 URL 与 IP 的映射关系，返回解析结果给客户端</li>
<li>如果域名不在本地 DNS，也不在缓存中，则查询根域名服务器（迭代查询）<ul>
<li>询问根域名服务器，得到顶级域名服务器</li>
<li>询问顶级域名服务器，得到权威域名服务器</li>
<li>权威域名服务器将 IP 地址返回给本地域名服务器</li>
<li>本地域名服务器将解析得到的 IP 地址返回给客户端</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>TCP 连接</code></li>
</ol>
<p>浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，三次握手，建立连接。</p>
<ol start="4">
<li><code>发送 HTTP 请求</code></li>
</ol>
<p>TCP 连接建立起来后，浏览器向服务端发送 HTTP 请求。</p>
<ol start="5">
<li><code>服务端处理请求并返回 HTTP 报文</code></li>
</ol>
<p>服务端接收到请求后，根据路径参数找到特定的请求处理器进行处理，将处理结果及相应视图返回给浏览器。<br>（如果使用的是 HTTPS，还需进行 TLS 握手，保证安全）</p>
<ol start="6">
<li><code>浏览器解析并渲染页面</code></li>
</ol>
<p>浏览器解析并渲染视图，若遇到 js 文件、css 文件等资源，则重复上述过程请求响应的资源。</p>
<ol start="7">
<li><code>断开连接</code></li>
</ol>
<p>四次挥手，断开连接。</p>
<h3 id="HTTP-是不保存状态的协议，如何保存用户状态？"><a href="#HTTP-是不保存状态的协议，如何保存用户状态？" class="headerlink" title="HTTP 是不保存状态的协议，如何保存用户状态？"></a>HTTP 是不保存状态的协议，如何保存用户状态？</h3><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#计网" >
    <span class="tag-code">计网</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/07/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Kubernetes/">
        <span class="nav-arrow">← </span>
        
          【学习笔记】Kubernetes 核心概念与架构
        
      </a>
    
    
      <a class="nav-right" href="/2023/07/22/%E3%80%90%E5%85%AB%E8%82%A1%E3%80%91MySQl%EF%BC%88%E6%9C%AA%E5%AE%8C%E7%BB%93%EF%BC%89/">
        
          【八股】MySQl（未完结）
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">七层模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-nav-text">1. OSI 七层模型介绍一下？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%AF%8F%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%AF%8F%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-nav-text">2. OSI 七层模型中每层的作用？每层协议？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-TCP-x2F-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-nav-text">3. TCP&#x2F;IP 四层模型和五层模型？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">4. 模型之间的数据是如何传输的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8E%BB%E6%8E%89%E8%A1%A8%E7%A4%BA%E5%B1%82%E5%92%8C%E4%BC%9A%E8%AF%9D%E5%B1%82%EF%BC%9F"><span class="toc-nav-text">5. 为什么要去掉表示层和会话层？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-OSI-%E6%A8%A1%E5%9E%8B%E5%92%8C-TCP-x2F-IP-%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-nav-text">6. OSI 模型和 TCP&#x2F;IP 模型之间的异同？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-nav-text">应用层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HTTP"><span class="toc-nav-text">HTTP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-HTTP-%E5%A4%B4%E9%83%A8%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-nav-text">1. HTTP 头部包含哪些内容？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E2%8C%9B%EF%B8%8F-%E9%95%BF%E8%BF%9E%E6%8E%A5-keep-alive-%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-nav-text">2. ⌛️ 长连接 keep-alive 和短连接的区别？使用场景？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93-HTTP-%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6%EF%BC%9F"><span class="toc-nav-text">3. 如何知道 HTTP 报文长度？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-nav-text">4. HTTP 请求方法有哪些？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-GET-%E5%92%8C-POST-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">5. GET 和 POST 区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-nav-text">6. 状态码？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-HTTP-x2F-1-1-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="toc-nav-text">7. HTTP&#x2F;1.1 缓存技术？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-HTTP-%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9F"><span class="toc-nav-text">8. 如何减少 HTTP 请求次数？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HTTP-%E5%90%84%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="toc-nav-text">HTTP 各版本对比</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-HTTP-x2F-1-1-%E5%92%8C-HTTP-x2F-1-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">1. HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-HTTP-x2F-1-X-%E5%92%8C-HTTP-x2F-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">2. HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E2%8C%9B%EF%B8%8F-HTTP-x2F-3-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-nav-text">3. ⌛️ HTTP&#x2F;3 了解吗？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HTTPS"><span class="toc-nav-text">HTTPS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E2%8C%9B%EF%B8%8F-HTTPS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-x2F-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">1. ⌛️ HTTPS 的工作流程&#x2F;建立连接的过程？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-HTTP-vs-HTTPS%EF%BC%9F"><span class="toc-nav-text">2. HTTP vs HTTPS？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%EF%BC%9FHTTPS-%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-nav-text">3. 有哪些加密方式？HTTPS 的加密方式？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-HTTPS-%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-nav-text">4. HTTPS 实现安全传输的策略？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E2%8C%9B%EF%B8%8F-%E5%85%B6%E4%BB%96"><span class="toc-nav-text">⌛️ 其他</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#URL-%E5%92%8C-URI%EF%BC%9F"><span class="toc-nav-text">URL 和 URI？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BD%91%E9%A1%B5%E8%A7%A3%E6%9E%90%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">网页解析全过程？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#HTTP-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-nav-text">HTTP 是不保存状态的协议，如何保存用户状态？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-nav-text">传输层</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://by-yanxx.github.io/2023/07/22/【八股】计网（未完结）/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    <p>Stay hungry. Stay foolish.</p>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>